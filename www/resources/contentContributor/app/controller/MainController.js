/*
 * File: resources/contentContributor/app/controller/MainController.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('ContentContributor.controller.MainController', {
    extend: 'Ext.app.Controller',
    alias: 'controller.MainController',

    models: [
        'taxonomyTermModel'
    ],

    fieldReplicate: function(button, e, eOpts) {
        var nouvChamp=button.up().getComponent(1).cloneConfig();
        nouvChamp.anchor = '90%';
        nouvChamp.style = '{float:left;}';
        var enrobage =Ext.widget('fieldWrapper');
        enrobage.add(nouvChamp);
        enrobage.getComponent('helpBouton').setTooltip("Réplique du champ "+button.up().getComponent(1).fieldLabel);
        var supprimeur = Ext.widget('button', {iconCls: 'close', margin: '0 0 0 5', tooltip: 'Enlever', itemId: 'boutonEffaceurChamps'});
        supprimeur.on('click', function(){
            button.valeursM--;
            button.up().up().remove(supprimeur.up());
        });
        enrobage.add(supprimeur);
        button.up().up().insert(button.up().up().items.indexOf(button.up())+button.valeursM, enrobage);
        button.valeursM++;
    },

    saveContent: function(button, e, eOpts) {
        if (Ext.getCmp("MainForm").getForm().isValid()){
            if (Ext.getCmp("MainForm").isUpdatingContent){

            } else {
                var myFields = Ext.getCmp("MainForm").getForm().getValues();
                var newContent = Ext.create('ContentContributor.model.contentDataModel', {
                    text:myFields.text,
                    fields:myFields,
                    taxonomy: { },
                    online:true,
                    status:button.cStatus,
                    typeId:AppGlobals.typeId

                });
                newContent.set("writeWorkspace",AppGlobals.currentWorkspace);
                newContent.set("target",[AppGlobals.currentWorkspace]);
                var taxoRes = {};
                if (!Ext.isEmpty(Ext.getCmp("taxonomyFieldset"))){
                    Ext.Array.forEach(Ext.getCmp("taxonomyFieldset").query("field"), function(leField){
                        taxoRes[leField.name]=leField.getValue();
                        delete myFields[leField.name];
                    });
                }
                taxoRes.navigation=[AppGlobals.currentPage];
                newContent.set("taxonomy",taxoRes);
                newContent.set("fields",myFields);

                Ext.getCmp("MainForm").setLoading(true);
                Ext.getStore("Contents").addListener("write", function(){

                    Ext.getCmp("MainForm").setLoading(false);
                    if (AppGlobals.contextQueryType=="manual"){
                        var queryRecord = Ext.getStore("QueriesStore").getRange()[0];
                        var qArray =Ext.clone(queryRecord.get("query"));
                        qArray.push(newContent.get("id"));
                        queryRecord.set("query", qArray);
                    }
                    Ext.Msg.alert('Succès', 'Le nouveau contenu a bien été enregistré', function(){
                        window.parent.destroyModal("add-content-window");
                    });
                },this, {single:true});


                    Ext.getStore("Contents").add(newContent);

                }
            } else {
                Ext.Msg.alert('Erreur', 'Certains champs ne sont pas valides');
            }
    },

    onBasefieldBeforeRender: function(component, eOpts) {
        if ((component.isXType("field"))||(component.isXType("checkboxgroup"))){
            component.labelSeparator=" ";
            if (component.isXType("datefield")){
                component.submitFormat='U';
                component.altFormats='U|m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j';
            }    
        }
    },

    initializeContentForm: function(contentType) {
        Ext.getCmp("MainForm").setTitle("Nouveau contenu : "+contentType.type);
        this.renderMainFields(contentType.fields);
        this.renderTaxoFields(contentType.vocabularies);
    },

    renderMainFields: function(fields) {
        var target = Ext.getCmp("MainForm");
        Ext.Array.forEach(fields, function(field,index){
            var configurator=Ext.clone(field.config);
            if (field.cType =='treepicker'){
                configurator.store = Ext.create("Ext.data.TreeStore", {
                    autoLoad: false,
                    autoSync: false,
                    remoteFilter: true,
                    model: 'ContentContributor.model.taxonomyTermModel',
                    proxy: {
                        type: 'ajax',
                        api: {
                            read: 'taxonomy-terms/navigation-tree'
                        },
                        reader: {
                            type: 'json',
                            getResponseData: function(response) {
                                var data, error;

                                try {
                                    data = Ext.decode(response.responseText);
                                    if (Ext.isDefined(data.data)){data.children=data.data;}// error fix
                                    return this.readRecords(data);
                                } catch (ex) {
                                    error = new Ext.data.ResultSet({
                                        total  : 0,
                                        count  : 0,
                                        records: [],
                                        success: false,
                                        message: ex.message
                                    });

                                    this.fireEvent('exception', this, response, error);
                                    console.log(ex);

                                    Ext.Logger.warn('Unable to parse the JSON returned by the server');

                                    return error;
                                }
                            },
                            messageProperty: 'message'
                        }
                    },
                    sorters: {
                        property: 'orderValue'
                    }
                });
                configurator.store.load();
                configurator.valueField="id";
                configurator.displayField="text";
                configurator.plugins=[Ext.create("Ext.ux.form.field.ClearButton")];
            }
            else if (field.cType == 'combobox') {
                var monStore=  Ext.create('Ext.data.Store', Ext.clone(field.store));
                configurator.store = monStore;
            }
            configurator.labelSeparator=" ";
            try {var newField = Ext.widget(field.cType, configurator);} catch(err){
            var newField = Ext.create(field.cType, configurator);
        }
        var wrapping= Ext.widget("fieldWrapper");
        newField.anchor = '90%';
        newField.style = '{float:left;}';
        wrapping.add(newField);
        wrapping.getComponent('helpBouton').setTooltip(configurator.tooltip);
        if (Ext.isEmpty(configurator.tooltip)){
            wrapping.getComponent('helpBouton').hidden=true;
        } 
        if (newField.multivalued) {
            enrobage.add(Ext.widget('button', {iconCls: 'add',valeursM: 1, margin: '0 0 0 5', tooltip: 'Valeurs multiples', itemId: 'fieldReplicatorBtn'}));

        }
        target.add(wrapping);


    });
    },

    renderTaxoFields: function(vocabularies) {
        Ext.Array.remove(vocabularies, "navigation");
        if (!Ext.isEmpty(vocabularies)){
            var target = Ext.getCmp("MainForm");
            var taxoFieldset = Ext.widget("fieldset", {title:"Taxonomie", collapsible:true, id:"taxonomyFieldset"});
            var lesTaxo = vocabularies;
            var i=0;
            for (i=0; i<lesTaxo.length; i++) {
                var leVocab = Ext.getStore('TaxonomieDataJson').findRecord('id', lesTaxo[i]);
                if (leVocab.get("inputAsTree")){
                    var storeT = Ext.create("Ext.data.TreeStore", {
                        model:"Rubedo.model.taxonomyTermModel",
                        remoteFilter:"true",
                        proxy: {
                            type: 'ajax',
                            api: {
                                read: 'taxonomy-terms/tree'
                            },
                            reader: {
                                type: 'json',
                                messageProperty: 'message'
                            },
                            encodeFilters: function(filters) {
                                var min = [],
                                    length = filters.length,
                                    i = 0;

                                for (; i < length; i++) {
                                    min[i] = {
                                        property: filters[i].property,
                                        value   : filters[i].value
                                    };
                                    if (filters[i].type) {
                                        min[i].type = filters[i].type;
                                    }
                                    if (filters[i].operator) {
                                        min[i].operator = filters[i].operator;
                                    }
                                }
                                return this.applyEncoding(min);
                            }
                        },
                        filters: {
                            property: 'vocabularyId',
                            value: leVocab.get("id")
                        }

                    });
                    var toUse="Ext.ux.TreePicker";
                    if(leVocab.get("multiSelect")){toUse="Ext.ux.TreeMultiPicker";}
                    if(leVocab.get("id")=='navigation'){storeT.getProxy().api={read:"taxonomy-terms/navigation-tree"};}
                    storeT.load();
                    var selecteur = Ext.create(toUse, {
                        name:leVocab.get("id"),
                        fieldLabel: leVocab.get("name"),
                        store: storeT,
                        anchor:"90%",
                        ignoreIsNotPage:true,
                        displayField:"text",
                        allowBlank: !leVocab.data.mandatory,
                        plugins:[Ext.create("Ext.ux.form.field.ClearButton")]
                    });


                } else {
                    var storeT = Ext.create('Ext.data.JsonStore', {
                        model:"ContentContributor.model.taxonomyTermModel",
                        remoteFilter:"true",
                        proxy: {
                            type: 'ajax',
                            api: {
                                read: 'taxonomy-terms'
                            },
                            reader: {
                                type: 'json',
                                messageProperty: 'message',
                                root: 'data'
                            },
                            encodeFilters: function(filters) {
                                var min = [],
                                    length = filters.length,
                                    i = 0;

                                for (; i < length; i++) {
                                    min[i] = {
                                        property: filters[i].property,
                                        value   : filters[i].value
                                    };
                                    if (filters[i].type) {
                                        min[i].type = filters[i].type;
                                    }
                                    if (filters[i].operator) {
                                        min[i].operator = filters[i].operator;
                                    }
                                }
                                return this.applyEncoding(min);
                            }
                        },
                        filters: {
                            property: 'vocabularyId',
                            value: leVocab.get("id")
                        }

                    });
                    storeT.on("beforeload", function(s,o){
                        o.filters=Ext.Array.slice(o.filters,0,1);
                        if (!Ext.isEmpty(o.params.comboQuery)){

                            var newFilter=Ext.create('Ext.util.Filter', {
                                property:"text",
                                value:o.params.comboQuery,
                                operator:'like'
                            });

                            o.filters.push(newFilter);

                        }


                    });


                    var selecteur = Ext.widget('comboboxselect', {
                        name:leVocab.get("id"),
                        anchor:"90%",
                        fieldLabel: leVocab.get("name"),
                        submitValue:false,
                        autoScroll: false,
                        store: storeT,
                        queryMode: 'remote',
                        queryParam: 'comboQuery',
                        minChars:3,
                        displayField: 'text',
                        valueField: 'id',
                        filterPickList: true,
                        typeAhead: true,
                        forceSelection: !leVocab.data.expandable,
                        createNewOnEnter: leVocab.data.expandable,
                        multiSelect: leVocab.data.multiSelect,
                        allowBlank: !leVocab.data.mandatory
                    });
                }
                if (AppGlobals.contextQueryType=="simple"){
                    if (!Ext.isEmpty(AppGlobals.contextQuery.vocabularies[leVocab.get("id")])) {
                        selecteur.setValue(AppGlobals.contextQuery.vocabularies[leVocab.get("id")].terms);
                        if (!Ext.isEmpty(AppGlobals.contextQuery.vocabularies[leVocab.get("id")].terms)){
                            selecteur.setReadOnly(true);
                        }
                    }
                }

                var enrobage =Ext.widget('fieldWrapper');
                enrobage.add(selecteur);
                enrobage.getComponent('helpBouton').setTooltip(leVocab.data.helpText);
                if (Ext.isEmpty(leVocab.data.helpText)){enrobage.getComponent('helpBouton').hide();}
                taxoFieldset.add(enrobage);

            }
            target.add(taxoFieldset);
            Ext.getCmp("taxonomyFieldset").doLayout();
        }
    },

    init: function(application) {
        Ext.require("Rubedo.view.CKEField");
        Ext.require("Rubedo.view.localiserField");
        Ext.require("Rubedo.view.localiserFieldComponent");
        Ext.require("Rubedo.view.externalMediaField");
        Ext.require("Rubedo.view.externalMediaFieldComponent");
        Ext.require("Ext.ux.TreePicker");
        Ext.require("Rubedo.view.DCEField");
        Ext.require("Rubedo.view.DCEFieldComponent");
        Ext.create("Rubedo.store.ContentSelectorStore");
        Ext.create("Rubedo.store.TCNDepComboCS");
        Ext.create("Rubedo.store.SystemCTStore");
        Ext.require("Rubedo.view.contentPickerGrid");
        Ext.require("Rubedo.view.contentPickerWindow");
        Ext.create("Rubedo.store.MediaTypesFORDAMPicker");
        Ext.create("Rubedo.store.DAMPickerStore");
        Ext.create("Rubedo.store.TaxonomyForDam2");
        Ext.require("Rubedo.view.DAMMainView");
        Ext.require("Rubedo.view.ImagePickerField");
        Ext.require("Rubedo.view.ImageFieldComponent");
        Ext.require("Rubedo.view.ImagePickerWindow");
        Ext.define('AppGlobals', {singleton: true});

        this.control({
            "[itemId= 'boutonReplicateurChamps']": {
                click: this.fieldReplicate
            },
            "#mainDraftBtn, #mainSubmitBtn, #mainPublishBtn": {
                click: this.saveContent
            },
            "field": {
                beforerender: this.onBasefieldBeforeRender
            }
        });
    },

    mainAction: function() {
        var me=this;
        var options = decodeURIComponent(window.location.search.slice(1))
        .split('&')
        .reduce(function _reduce (a, b) {
            b = b.split('=');
            a[b[0]] = b[1];
            return a;
        }, {});
            AppGlobals.currentPage=options["current-page"];
            AppGlobals.currentWorkspace=options["current-workspace"];
            if (!Ext.isEmpty(options.queryId)){
                Ext.getStore("QueriesStore").filter("id",options.queryId);
                Ext.getStore("QueriesStore").addListener("load", function(a, records){
                    if (!Ext.isEmpty(records)){
                        AppGlobals.contextQuery=records[0].get("query");
                        AppGlobals.contextQueryType=records[0].get("type");
                    } else {
                        Ext.Msg.alert('Erreur', 'Erreur dans la récupération de la requête de contexte');
                    }
                    if (!Ext.isEmpty(options.typeId)){
                        Ext.Ajax.request({
                            url: 'content-types/find-one',
                            params: {
                                id: options.typeId
                            },
                            success: function(response){
                                var result = Ext.JSON.decode(response.responseText).data;
                                AppGlobals.typeId=options.typeId;
                                Ext.getCmp("MainViewport").add(Ext.widget("MainForm"));
                                me.initializeContentForm(result);
                            }
                        });
                    }
                }, this, {single:true});
                } else {
                    if (!Ext.isEmpty(options.typeId)){
                        Ext.Ajax.request({
                            url: 'content-types/find-one',
                            params: {
                                id: options.typeId
                            },
                            success: function(response){
                                var result = Ext.JSON.decode(response.responseText).data;
                                AppGlobals.typeId=options.typeId;
                                Ext.getCmp("MainViewport").add(Ext.widget("MainForm"));
                                me.initializeContentForm(result);
                            }
                        });
                    }
                }

    }

});
