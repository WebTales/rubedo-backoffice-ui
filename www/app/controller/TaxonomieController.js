/*
 * File: app/controller/TaxonomieController.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Rubedo.controller.TaxonomieController', {
    extend: 'Ext.app.Controller',

    models: [
        'termeTaxonomieModel'
    ],
    views: [
        'TermesTaxonomieTree',
        'nouveauTaxoFenetre'
    ],

    selectVocabulary: function(selModel, record, index, options) {
        var tablepanel=Ext.getCmp("AdminfTaxonomieGrid");
        var filArianne = tablepanel.findParentByType('window').getDockedComponent('filArianne');
        var typeFil = filArianne.getComponent('type');
        if (Ext.isDefined(typeFil)) {typeFil.setText(record.data.titre);}
        else { typeFil= Ext.widget('button',{iconCls: "page_taxonomy", text:record.get("name"), itemId:'type'});
        filArianne.add(typeFil);
    }
    Ext.getCmp("ProprietesTaxonomie").getForm().loadRecord(record);



    if (Ext.isDefined(Ext.getCmp('TermesTaxonomieTree'))){
    Ext.getCmp('TermesTaxonomieTree').destroy();}
    var data =  record.get("terms");
    var store = Ext.create('Ext.data.TreeStore', {
        model: 'KECMours.model.termeTaxonomieModel',
        root: Ext.clone(data),
        proxy: {
            type: 'memory'
        }
    });
    var arbre = Ext.widget('TermesTaxonomieTree', {store: store, flex:1});

    Ext.getCmp('conteneurAdminfTaxo').add(arbre);
    arbre.getStore().getRootNode().expand(true);
    },

    removeTerm: function(button, e, options) {
        var cible = Ext.getCmp('TermesTaxonomieTree').getSelectionModel().getLastSelected();
        if (Ext.isDefined(cible)) {
            cible.remove();
        }
    },

    addTerm: function(button, e, options) {
        if (Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().getLastSelected() !== null) {

            var champT = Ext.getCmp('nouveauTermeTaxoField');
            if (champT.isValid()) {
                var cibleI = Ext.getCmp('TermesTaxonomieTree').getSelectionModel().getLastSelected();
                if (cibleI !== null) {
                    cibleI.appendChild({text: champT.getValue()});
                    cibleI.expand();
                    Ext.getCmp('nouveauTermeTaxoField').setValue();
                } 



            }
        }
    },

    saveVocabulary: function(button, e, options) {
        if (Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().getLastSelected() !== null) {
            var cibleR=Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().getLastSelected();
            cibleR.beginEdit();
            if (Ext.getCmp("ProprietesTaxonomie").getForm().isValid()){
                cibleR.set(Ext.getCmp("ProprietesTaxonomie").getForm().getValues());
            }
            var racineR = Ext.getCmp('TermesTaxonomieTree').getStore().getRootNode();
            var nouvRacine = {text: racineR.data.text, children: this.recupereFils(racineR.childNodes)};  
            cibleR.set("terms",Ext.clone(nouvRacine));
            cibleR.endEdit();
        }
    },

    deleteVocabulary: function(button, e, options) {
        var cible = Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().getSelection()[0];
        if (Ext.isDefined(cible)) {
            var window = Ext.widget('delConfirmZ');
            Ext.getCmp('ViewportPrimaire').add(window);
            window.show();
            Ext.getCmp('delConfirmZOui').on('click', function() { 
                Ext.getCmp('AdminfTaxonomieGrid').getStore().remove(cible);
                Ext.getCmp('delConfirmZ').close();
            });  

        }
    },

    newVocabulary: function(button, e, options) {
        if (Ext.getCmp('champCreerTaxo').isValid()) {
            var nouveauVocab = Ext.create('model.taxonomieDataModel', {
                name: Ext.getCmp('champCreerTaxo').getValue(),
                extendable: false,
                multiSelect: true,
                mandatory: false,
                terms:	{
                    children:[
                    ]
                }


            });
            Ext.getCmp('AdminfTaxonomieGrid').getStore().add(nouveauVocab);
            Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().select(nouveauVocab);
            this.selectVocabulary(Ext.getCmp('AdminfTaxonomieGrid'),nouveauVocab);
            Ext.getCmp('nouveauTaxoFenetre').close();
        }    
    },

    openVocabWindow: function(button, e, options) {
        var window = Ext.widget('nouveauTaxoFenetre');
        Ext.getCmp('ViewportPrimaire').add(window);
        window.show();

    },

    newTerm: function(button, e, options) {
        if (Ext.getCmp('AdminfTaxonomieGrid').getSelectionModel().getLastSelected() !== null) {

            var champT = Ext.getCmp('nouveauTermeTaxoField');
            if (champT.isValid()) {
                var cibleI = Ext.getCmp('TermesTaxonomieTree').getSelectionModel().getLastSelected();
                if (cibleI !== null) {
                    cibleI.data.text= champT.getValue();
                    Ext.getCmp('nouveauTermeTaxoField').setValue();
                    Ext.getCmp('TermesTaxonomieTree').getView().refresh();
                } 
            }
        }
    },

    recupereFils: function(cible) {
        var fils = [ ];
        if (cible.length>0) {
            var f=0;
            for (f=0; f<cible.length; f++) {
                fils.push({text: cible[f].data.text, children: this.recupereFils(cible[f].childNodes)});
            }    
        }
        return fils;
    },

    init: function(application) {
        this.control({
            "#AdminfTaxonomieGrid": {
                select: this.selectVocabulary
            },
            "#boutonSupprimerTermesTaxo": {
                click: this.removeTerm
            },
            "#boutonAjouterTermesTaxo": {
                click: this.addTerm
            },
            "#boutonEnregistrerTaxo": {
                click: this.saveVocabulary
            },
            "#boutonSupprimerTaxo": {
                click: this.deleteVocabulary
            },
            "#boutonCreerTaxo": {
                click: this.newVocabulary
            },
            "#boutonCreerTaxonomie": {
                click: this.openVocabWindow
            },
            "#boutonModifierTermesTaxo": {
                click: this.newTerm
            }
        });
    }

});
