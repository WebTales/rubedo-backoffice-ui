/*
 * File: app/controller/LocalisationController.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Rubedo.controller.LocalisationController', {
    extend: 'Ext.app.Controller',
    alias: 'controller.LocalisationController',

    models: [
        'LocalisationModel'
    ],
    stores: [
        'LocalisationStore'
    ],

    onButtonAfterRender1: function(component, eOpts) {
        try {
            component.on("click", function(){
                Ext.widget('callout', {
                    cls: 'gray',
                    width: 400,
                    html:Rubedo.RubedoAppHelp[component.RApplication],
                    calloutArrowLocation: 'top-right',
                    target: component,
                    relativePosition: 't-b',
                    relativeOffsets: [-184,0],
                    fadeInDuration: 200,
                    fadeOutDuration: 200,
                    dismissDelay: 60000
                }).show();

            });
        } catch (err){
            console.log("failed to show application help");
        }
    },

    onComponentBeforeRender: function(component, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
                if (!Ext.isEmpty(configs.tooltip)) {
                    component.setTooltip(configs.tooltip);
                }
            }
            if ((component.isXType("button"))&&(component.scale=="large")&&(Ext.isEmpty(component.dontStretch))){
                component.minWidth=48;
            }
        }
        if ((component.isXType("field"))||(component.isXType("checkboxgroup"))||(component.isXType("radiogroup"))){
            component.labelSeparator=" ";
            if (component.name=="localizable"){
                //temporary localiser hide
                component.hide();
            }
        }
    },

    onBasefieldAdded: function(component, container, pos, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
            }
        }
        if (!Ext.isEmpty(component.RTip)){
            component.anchor="90%";
            container.insert(pos,Ext.widget("RHelpBtn", {tooltip:component.RTip}));
        }
    },

    onFieldsetAfterRender: function(component, eOpts) {
        var task = new Ext.util.DelayedTask(function(){
            component.setTitle(component.title);
        });
        task.delay(100);
    },

    init: function(application) {
        var me=this;
        Ext.override(Ext.form.field.Date, {
            submitFormat:'U',
            altFormats:'U|m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j'
        });
        Ext.require("Ext.ux.callout.Callout");

        Ext.Date.defaultFormat="d/m/Y";
        //define localisation singletons 
        Ext.define("Rubedo.RubedoAppHelp",{
            singleton:true,
            "pages": "<p>The different pages of a site can easily be enriched with functional blocks.The 'Pages' application allows:</p> <ul><li>to access the tree view of sites maintained on the platform,</li> <li>to add pages based on existing pages masks</li> <li>to modify or delete pages,</li> <li> to add functionalities to pages through the library of functional blocks</li> <li>to preview the display of a page in front-office,</li> <li>to manage SEO settings,</li> <li>to manage reading and writing rights through workspaces.</li></ul>",
            "sites": "<p>Rubedo natively offers the site building feature.The 'Sites' application allows:</p> <ul><li>to create new sites through a wizard</li> <li>on the basis of existing models or from a blank template</li> <li>to modify the settings of existing sites</li></ul>",
            "masks": "<p>Pages masks represent the different rendering templates available in front office.The \"Page masks\" application allows:</p> <ul><li>to create new layout templates in rows and columns</li> <li>to duplicate existing masks, possibly from one site to another</li> <li>to manage the persistent functional blocks, such as menus</li> <li>to form a library of elements (rows, columns, or blocks) that is reusable between masks</li> <li>to manage Responsive Design settings : visibility of rows, columns and blocks on phone, tablet, or desktop</li></ul>",
            "contentTypes": "<p>Content types correspond to the structured data managed by Rubedo: articles, news,.. .etc. The 'Content Types' application allows :</p> <ul><li>to create new content types using an advanced editor</li> <li>to set up input controls, default values, mandatory state for each field</li> <li>to modify existing content types</li> <li>to manage localizable (several language), and searchable state of each field</li> <li>to manage input aid</li> <li>to declare vocabularies applicable to the classification of the contents</li> <li>to choose the workflow to apply to contents</li> <li>to declare read and write workspaces for contents</li></ul>",
            "damTypes": "<p>Digital asset types correspond to Rubedo-managed files: images, video, audio, animation or documents.'Digital Asset Types' application allows:</p> <ul><li>to create new digital asset types (image, document, video, audio, animation)</li> <li>to add metadata (author, copyright, caption, etc) using an advanced editor</li> <li>to set input controls, default values, mandatory state for each field</li> <li>to edit existing digital asset types</li> <li>to manage localizable(several language) and searchable state for each field</li> <li>to manage input aid</li> <li>to choose vocabularies eligible as classification</li> <li>to declare read and write workspaces</li></ul>",
            "queries": "<p>Queries are used to create automatic or manual lists of contents and digital assets.The \"Queries\" application allows:</p> <ul><li>to create and save simple or advanced, content or digital asset queries</li> <li>to edit or remove existing queries</li> <ul>",
            "taxonomy": "<p>Taxonomy alows for the creation of a multi-dimensional classification of contents and digital assets.The \"Taxonomy\" application allows:</p> <ul><li>to create new vocabularies and add terms using a tree</li> <li>to apply rights for workspaces and inpu aid for each vocabulary</li> <li>to define vocabulary settings: expandable, multi-choice, mandatory</li></ul>",
            "groups": "<p>Groups are used to associate users with rights in the form of workspaces and roles.The 'Groups' application allows:</p> <ul><li>to create groups of users</li> <li>to add users to these groups</li> <li>to set up the rights associated with each group: workspaces (read, write, default) and roles</li> <li>to manage groups (deletion, modification, inheritance)</li></ul>",
            "workspaces": "<p>Workspaces are used to restrict access (read, write or broadcast) on content, digital asset types or sites topics to specific user groups.The 'Workspaces' application allows:</p> <ul><li>to create workspaces</li> <li>to delete or edit workspaces</li></ul>",
            "users": "<p>Front-office and back-office users are grouped in an internal directory. The rights granted to a user are linked to groups to which he belongs.The 'Users' application allows:</p> <ul><li>to add users</li> <li>to complete profiles (email, service, job title, photo,...)</li> <li>to manage  access and rights (identifier, password, groups, account validityt)</li></ul> ",
            "contents": "<p>Rubedo manages a transverse repository of content that can be published on different sites and workspaces.The \"Contents\" application allows:</p> <ul><li>to create contents using an existing content type</li> <li>to manage its status in the workflow of publication attributed to the content type</li> <li>to manage delayed publication</li> <li>to classify content using vocabularies allowed for this contnet type</li> <li>to associate contents to contribution and diffusion workspaces</li> <li>to modify contents</li> <li>to duplicate contents</li> <li>to add contents to favorites</li></ul> ",
            "dam": "<p>The DAM allows you to manage digital assets (images, video, audio, animation or documents) based on predefined digital asset types.The \"DAM\" application allows:</p> <ul><li>to create digital assets using existing digital asset types</li> <li>to upload digital assets and apply metadata settings</li> <li>to classify digital assets using vocabularies allowed for this digital asset type</li> <li>to set up contributionand diffusion workspaces </li> <li>to edit digital assets</li> <li>to add digital assets to favorites</li></ul>",
            "forms": "<p>This application is used to conduct online surveys. Stages and questions can be easly created and manged through drag and drop. The \"Surveys\" application allows:</p> <ul><li>to add, edit, delete, and duplicate a survey</li> <li>to add a survey to favorites</li> <li>to manage the settings and unique answer conditions of a survey and put it online</li> <li>to create a survey using the tool palette of formatting (Wysiwyg, image, section, page, title) and settings (type of questions and their specific settings)</li> <li>to manage questions and answers (label settings(, input aid, mandatory state, conditionals, and options)</li> <li>to exploit the results of each survey by exporting to CSV format</li></ul>"

        });
        Ext.define("Rubedo.RubedoInterfaceLoc",{
            singleton:true
        });
        Ext.define("Rubedo.RubedoAutomatedElementsLoc",{
            singleton:true,
            "notifTitle": "Notification",
            "notifCreate": "<p>Succesful creation.</p>",
            "notifUpdate": "<p>Successful update.</p>",
            "notifDestroy": "<p>Successful deletion.</p>",
            "errorTitle": "Error",
            "serverConnectionError": "Server connection interrupted",
            "internalServerError": "Internal server error",
            "unkownError": "Unknown error",
            "activateText": "Activate",
            "pageHoldsDefaultError": "This page cannot be deleted because it u one of its decendantes is used as a detail of the site page",
            "pageHoldsDefaultServerError": "Error in the determination of the deletable status of the page",
            "deactivateText": "Disable",
            "windowBeforeUnloadMessage": "You will leave the Back Office and lose any unsaved changes.",
            "maskIsUsedText": "The mask cannot be deleted because it is used by pages.",
            "selectAnElementText": "Select an item",
            "columnText": "Column",
            "lignText": "Line",
            "titleText": "Title",
            "displayTitleText": "Display the title",
            "visibilityText": "Visibility",
            "telephoneText": "Phone",
            "tabletText": "Tablet",
            "computerText": "Desktop",
            "HTMLClassText": "HTML class",
            "HTMLIdText": "HTML ID",
            "styleText": "Style",
            "tagText": "Tag",
            "displayAsTabsText": "Display in tabs",
            "displayRowTagText": "Display the row tag",
            "displayRowFluidTagText": "Show row-fluid tag",
            "includeInAContainerText": "Include in a container",
            "includeInAContainerFluidText": "Include in a fluid container",
            "containerIdText": "ID of the container",
            "containerClassText": "Container class",
            "mainColumnText": "Main column",
            "mainColumnRTip": "Sets the display location for content detail in pages using this mask.",
            "showSpanAndOffsetText": "Display the span and offset",
            "offsetText": "Offset",
            "spanText": "Span",
            "columnIdRecoveryError": "Error in the recovery of a column identifier",
            "displayInADivText": "Display in a div",
            "divIdText": "ID of the div",
            "divClassText": "The div class",
            "blockText": "Block",
            "URLPrefixText": "URL Prefix",
            "invalidMetaError": "Some metadata fields are invalid.",
            "invalidTaxoError": "Some taxonomy fields are invalid.",
            "invalidFieldsError": "Some fields are invalid.",
            "insufficientContentRightsError": "You have insufficient rights to view or modify this content",
            "newContentText": "New content",
            "maxOneLocFieldError": "A content type cannot have multiple fields of type \"Location\".",
            "contentTypeIsUsedError": "This content type is used by content and therefore cannot be deleted.",
            "warningTitle": "Warning",
            "contentTypeIncompatModifError": "The content type is used by content and these amendments are not compatible.",
            "contentTypeModifWarning": "This content type is used by content. Changing it could have repercussions. </br> Would you like to continue?",
            "fieldReplicaText": "Replica of the field",
            "successTitle": "Success",
            "contentsDeleteError": "Error in deleting content",
            "contentTypeHasBeenEmptiedText": "The content type has been emptied",
            "fieldNameAlreadyUsedError": "Name already used by another field",
            "passwordsDoNotMatchError": "Passwords don't match",
            "passwordChangedText": "Password changed",
            "rightsRecoveryError": "Error in the recovery of the rights",
            "tokenRecoveryError": "Error in retrieving the security token",
            "siteModifWarning": "The modification of this site will involve the closing of the page management window. This will result in the loss of any changes not saved in that window. </br> Do you want to continue?",
            "pageURLRecoveryError": "Error in retrieving the url of the page",
            "pagePreviewText": "This is an overview of this page as available online on",
            "associatedMaskText": "Associated mask",
            "pagePropertiesInvalidError": "The properties of the page are invalid.",
            "stageText": "Step",
            "onText": "out of",
            "ascText": "Ascending",
            "descText": "Descending",
            "andText": "And",
            "thenText": "Then",
            "mediaTypeIsUsedError": "This type of media is used by media and therefore cannot be deleted.",
            "invalidRightsPropertiesError": "Invalid rights configuration",
            "newDamText": "New media",
            "DAMEditText": "Edition of the media",
            "DAMDisplayText": "Display of the media",
            "searchText": "Search",
            "identifierRecoveryError": "Error in the recovery of an identifier",
            "invalidFormPropertiesError": "Invalid form properties",
            "fileAnalysisError": "Error in parsing the file",
            "identifiedFieldsText": "identified fields and",
            "importableContentsText": "importable contents",
            "importedContentsText": "contents imported",
            "importError": "Error during import",
            "eligibleContentTypesText": "Eligible content types",
            "eachContentMustVerifyRulesText": "Each content must verify the following rules",
            "eachContentMustVerifyAtLeastOneRuleText": "Each content must verify at least one of the following rules",
            "taxonomyText": "Taxonomy",
            "rulesAndSortsOnFieldsText": "Rules and sorting on content fields",
            "ascSortText": "Sort ascending",
            "descSortText": "sort descending",
            "relationBetweenRulesText": "Relationship between the rules",
            "creationText": "Creation",
            "lastUpdateText": "Last modified",
            "noVocabForTheseCtText": "No vocabulary available for this set of content types",
            "ruleText": "Rule",
            "tRuleAllText": "Contains all the terms",
            "tRuleAllRecText": "Contains all the terms or at least a descendant per term",
            "tRuleSomeText": "Contains at least one of the terms",
            "tRuleSomeREcText": "Contains at least one of the terms or at least one of the descendants of one of the terms",
            "tRuleNotText": "Does not contain any of the following terms",
            "tRuleNotRecText": "Does not contain the following terms or their descendants",
            "CTMustHaveTitleError": "The content type must have a 'Title' field",
            "CTMustHaveOnlyOneTitleError": "The content type must have only a single field of type \"title\"",
            "CTMustHaveOnlyOneSummaryError": "The content type must have only a single field of type \"Summary\"",
            "CRMustHaveOnlyOneLocFieldError": "The content type must have only a single field of type 'Location'",
            "notMentionedText": "not filled",
            "showOnlyIfText": "Displayed if and only if",
            "orText": "Or",
            "rootText": "Root",
            "esGeoQueryText": "Geolocated Elastic Search Query Wizard",
            "esQueryText": "Elastic Search Query Wizard",
            "esDAMQueryText": "DAM Elastic Search Query Wizard",
            "keywordsText": "Keywords",
            "defaultKeywordsText": "Default keywords",
            "defaultSinglePageText": "Default detail page",
            "homePageText": "Homepage",
            "rolesText": "Roles",
            "authorText": "Author",
            "versionText": "Version",
            "contentsText": "Contents",
            "displayText": "Display",
            "publishedText": "published",
            "pendingText": "pending validation",
            "draftText": "draft",
            "refusedText": "refused",
            "yesText": "Yes",
            "noText": "No",
            "mediasText": "Media",
            "simpleQueryText": "Simple query",
            "manualQueryText": "Manual query",
            "restoreText": "Restore",
            "originalFileMText": "Original file *",
            "noneText": "None",
            "basicText": "Basic",
            "formUniqueAnswerMessage": "You have already completed this survey. Thank you.",
            "formEndMessage": "Thank you for completing this survey.",
            "oldVersionText": "(A more recent version of Rubedo is available)",
            "summaryText": "Summary",
            "showDesktopTooltip": "Show desktop",
            "userText":"user",
            "usersText":"users",
            "emptyText":"empty",
            "groupsText":"Groups",
            "removeText":"Remove",
            "duplicateFieldText":"Duplicate of the field",
            "duplicateText":"Duplicate",
            "multivaluedText":"Multivalued",
            "searchableText":"Searchable",
            "localizableText":"Localizable",
            "optionalText":"Optional",
            "fileTypeText":"File type",
            "tooltipText":"Tooltip",
            "nameText":"Name",
            "labelText":"Label",
            "fileFieldText":"File",
            "fileFieldDescription":"<h2>File field<\/h2> <\/br> <p>This field allows for the upload of files.<\/p>",
            "databaseIsUpToDateText":"Database is up to date",
            "databaseNeedsUpdateText":"Database update required",
            "databaseUpdateWarning":"This action will update the Rubedo database. It is recommended that you back-up your data before starting. Would you like to continue ?",
            "databaseUpdatedToText":"The database has been updated to version",
            "folderViewText":"Folder view",
            "switchToFolderViewText": "Switch to folder view",
            "searchViewText":"Search view",
            "switchToSearchViewText":"Switch to search view",
            "notFiledText": "Not filed",
            "mediaTypeText":"Media type",
            "filesUploadedText":"files uploaded",
            "allText":"All",
            "contentTypeText":"Content type"    
        });
        // attach event and load localisation store
        /*Ext.getStore("LocalisationStore").on("load",function(){

        });*/
        //me.updateLocalisationSingletons();

        this.control({
            "#RHelpBtn": {
                afterrender: this.onButtonAfterRender1
            },
            "component": {
                beforerender: this.onComponentBeforeRender
            },
            "field, checkboxgroup, radiogroup": {
                added: this.onBasefieldAdded
            },
            "fieldset": {
                afterrender: this.onFieldsetAfterRender
            }
        });
    },

    produceInterfaceLocalisationJSON: function() {
        var result= { };
        var count=0;
        Ext.Object.each(Rubedo.view, function(a){
            var test=Ext.create("Rubedo.view."+a,{id:undefined});
            if (!Ext.isEmpty(test.localiserId)){
                count=count+1;
                if ((test.isXType("field"))||(test.isXType("radiogroup"))||(test.isXType("checkboxgroup"))){
                    result[test.localiserId]={
                        fieldLabel:test.fieldLabel,
                        boxLabel:test.boxLabel,
                        buttonText:test.buttonText,
                        RTip:test.RTip
                    };
                } else if (test.isXType("button")){
                    result[test.localiserId]={
                        text:test.text,
                        tooltip:test.tooltip
                    };
                } else if (test.isXType("menuitem")){
                    result[test.localiserId]={
                        text:test.text,
                        tooltip:test.tooltip
                    };
                }else if (test.isXType("fieldset")){
                    result[test.localiserId]={
                        title:test.title
                    };
                } else if (test.isXType("panel")){
                    result[test.localiserId]={
                        title:test.title,
                        tooltip:test.tooltip
                    };
                } else if (test.isXType("window")){
                    result[test.localiserId]={
                        title:test.title
                    };
                }else if (test.isXType("gridcolumn")){
                    result[test.localiserId]={
                        text:test.text
                    };
                } else {
                    console.log("unhandled localised component for id : "+test.localiserId); 
                    count=count-1;
                }
                if (!Ext.isEmpty(result[test.localiserId])){
                    Ext.Object.each(result[test.localiserId], function(key, value, myself) {
                        if (Ext.isEmpty(value)){
                            delete result[test.localiserId][key];
                        }
                    });
                }
            }
            try{
                Ext.Array.forEach(test.query("component"), function(component){
                    if (!Ext.isEmpty(component.localiserId)){
                        count=count+1;
                        if ((component.isXType("field"))||(component.isXType("radiogroup"))||(component.isXType("checkboxgroup"))){
                            result[component.localiserId]={
                                fieldLabel:component.fieldLabel,
                                boxLabel:component.boxLabel,
                                buttonText:component.buttonText,
                                RTip:component.RTip
                            };
                        } else if (component.isXType("button")){
                            result[component.localiserId]={
                                text:component.text,
                                tooltip:component.tooltip
                            };
                        } else if (component.isXType("menuitem")){
                            result[component.localiserId]={
                                text:component.text
                            };
                        }else if (component.isXType("fieldset")){
                            result[component.localiserId]={
                                title:component.title
                            };
                        } else if (component.isXType("panel")){
                            result[component.localiserId]={
                                title:component.title,
                                tooltip:component.tooltip
                            };
                        } else if (component.isXType("window")){
                            result[component.localiserId]={
                                title:component.title
                            };
                        }else if (component.isXType("gridcolumn")){
                            result[component.localiserId]={
                                text:component.text
                            };
                        } else {
                            console.log("unhandled localised component for id : "+component.localiserId); 
                            count=count-1;
                        }
                        if (!Ext.isEmpty(result[component.localiserId])){
                            Ext.Object.each(result[component.localiserId], function(key, value, myself) {
                                if (Ext.isEmpty(value)){
                                    delete result[component.localiserId][key];
                                }
                            });
                        }
                    }
                });

            }catch(err){
                console.log(err);
            }
            test.destroy();
        });
        console.log(count+" localised interface components");
        return(Ext.JSON.encode(result));
    },

    updateLocalisationSingletons: function() {
        //new method using simple JSON files
        var userLanguage=Ext.getStore("CurrentUserDataStore").getRange()[0].get("language");
        if (Ext.isEmpty(userLanguage)){
            userLanguage="en";
        }
        if (userLanguage=="en"){
            Ext.Date.defaultFormat="m/d/Y";
        }
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/appHelp.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAppHelp, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAppHelp singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/componentLabels.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoInterfaceLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoInterfaceLoc singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/automatedElements.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAutomatedElementsLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAutomatedElementsLoc singleton could not be localized for the current language");
            }
        });
        if (!Ext.isEmpty(Ext.getStore("TypesChampsDataStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/fieldTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/fieldTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("TypesChampsDataStore").removeAll();
                            Ext.getStore("TypesChampsDataStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("FieldTypes store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("FieldTypes store could not retrieve generic structure");
                }
            });
        }
        if (!Ext.isEmpty(Ext.getStore("BlocsDataStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/blockTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/blockTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("BlocsDataStore").removeAll();
                            Ext.getStore("BlocsDataStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("Blocks store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("Blocks store could not retrieve generic structure");
                }
            });
        }
        if (!Ext.isEmpty(Ext.getStore("FormFieldTypesStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/formFieldTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/formFieldLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("FormFieldTypesStore").removeAll();
                            Ext.getStore("FormFieldTypesStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("Form Fields store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("Form Fields store could not retrieve generic structure");
                }
            });
        }




        /*
        //Old method using the database
        var userLanguage=Ext.getStore("CurrentUserDataStore").getRange()[0].get("language");
        Ext.Array.forEach(Ext.getStore("LocalisationStore").getRange(),function(localiser){
            var toUpdate =Rubedo[localiser.get("name")];
            if (!Ext.isEmpty(toUpdate)){
                Ext.apply(toUpdate, localiser.get("items"));
            }
        });
        if ((!Ext.isEmpty(userLanguage))&&(userLanguage!="fre")){
            Ext.Array.forEach(Ext.getStore("LocalisationStore").getRange(),function(localiser){
                var toUpdate =Rubedo[localiser.get("name")];
                if (!Ext.isEmpty(toUpdate)){
                    if(!Ext.isEmpty(localiser.get("i18n")[userLanguage])){
                        Ext.apply(toUpdate, localiser.get("i18n")[userLanguage]);
                    }
                }
            });
        }*/
    },

    createLocalisationDefaults: function() {
        //deprecated method
        /*var me = this;
        var defaultHelp={
        pages:"<p>Les différentes pages d'un site peuvent aisément être enrichies de blocs fonctionnels.L'application \"Pages\" permet :</p><ul><li> d'accéder à la vue arborescente des sites gérés sur la plateforme,</li><li> d'ajouter des pages sur la base des masques de pages existants,</li><li> de modifier ou de supprimer des pages,</li><li> d'ajouter des fonctionnalités aux pages par le biais de la bibliothèque de blocs fonctionnels,</li><li> de prévisualiser l'affichage d'une page en front-office,</li><li> de gérer les paramètres de référencement naturel,</li><li> de gérer les droits en lecture et écriture au travers des espaces de travail.</li></ul>",
        sites:"<p>Rubedo offre nativement la fonctionnalité d'usine à sites.L'application \"Sites\" permet  :</p><ul><li> de créer de nouveaux sites au travers d'un assistant de création </li><li>  sur la base de modèles existants ou en partant d'un modèle vierge </li><li>  de modifier le paramétrage des sites existants</li></ul>",
        masks:"<p>Les masques de pages représentent les différents gabarits de rendu disponibles en front-office.L'application \"Masques de pages\" permet  :</p><ul><li> de créer de nouveaux gabarits de mise en page en lignes et colonnes</li> <li>  de dupliquer des masques existants, éventuellement d'un site vers un autre</li> <li>  de gérer les blocs fonctionnels persistants, tels que les menus</li> <li>  de constituer une bibliothèques d'éléments (lignes, colonnes ou blocs) réutilisables entre les masques</li> <li>  de gérer les paramètres de \"Responsive Design\" : visibilité des lignes, colonnes et blocs sur téléphone, tablette, ou ordinateur</li> </ul>",
        contentTypes:"<p>Les types de contenus correspondent aux données structurées gérées par Rubedo : articles, news, ...etc.L'application \"Types de contenus\" permet  :</p><ul><li> de créer de nouveaux types de contenus à l'aide d'un éditeur avancé</li><li>  de paramétrer champs par champs les contrôles de saisie, les valeurs par défaut, le caractère obligatoire</li><li>  de modifier des types de contenus existants</li><li>  de gérer le caractère localisable (plusieurs langue), et recherchable d'un champ</li><li>  de gérer les aides à la saisie</li><li>  de déclarer les vocabulaires applicables à la classification du contenu</li><li>  de déclarer le workflow applicable au contenu</li><li>  de déclarer le ou les espaces de travail autorisés pour la création et la diffusion des contenus</li></ul>",
        damTypes:"<p>Les types de média correspondent aux fichiers gérés par Rubedo : images, vidéo, audio, animation ou documents bureautiques.L'application \"Types de médias\" permet  :</p><ul><li> de créer de nouveaux types de médias (image, document, vidéo, audio, animation)</li><li> d'y ajouter des métadonnées (auteur, copyright, sous-titrage, ...etc.) à l'aide d'un éditeur avancé</li><li> de paramétrer champs par champs les contrôles de saisie, les valeurs par défaut, le caractère obligatoire</li><li> de modifier des types de médias existants</li><li> de gérer le caractère localisable (plusieurs langue), et recherchable d'une métadonnée</li><li> de gérer les aides à la saisie</li><li> de déclarer les vocabulaires applicables à la classification d'un média</li><li> de déclarer le ou les espaces de travail autorisés pour la création et la diffusion des médias</li></ul>",
        queries:"<p>Les requêtes permettent de créer des listes automatiques ou manuelles de contenus, documents et médias.L'application \"Requêtes\" permet  :</p><ul><li> de créer et sauvegarder des requêtes simples ou avancées, sur les contenus ou les médias</li><li> de modifier des requêtes existantes</li><ul>",
        taxonomy:"<p>La taxonomie permet de créer une classification multi-dimensionnelle de l'ensemble des contenus (textes, médias et documents).L'application \"Taxonomie\" permet  :</p><ul><li> de créer de nouveaux vocabulaires arborescents et d'y ajouter des termes</li> <li> d'appliquer des droits pour les espaces de travail et une aide dédiée pour chaque taxonomie</li> <li> de définir ses caractéristiques : extensible, choix multiple, obligatoire</li></ul>",
        groups:"<p>Les groupes permettent de définir les utilisateurs, les espaces de travail et les rôles de gestion associés.L'application \"Groupes\" permet  :</p><ul><li> de créer des groupes d'utilisateurs</li><li>  d'ajouter des utilisateurs à ces groupes</li><li>  de paramétrer les droits associés à chaque groupe : Espaces de travail (en lecture, en contribution, par défaut) et rôles</li><li>  de gérer les groupes (suppression, modification, déplacement, hiérarchisation)</li></ul>",
        workspaces:"<p>Les espaces de travail permettent de réserver l'accès en lecture, écriture ou diffusion sur des types de contenus, de médias ou des rubriques de sites à des groupes d'utilisateurs spécifiques.L'application \"Espaces de travail\" permet  :</p><ul><li> de créer des espaces</li><li> de supprimer les espaces de travail</li></ul>",
        users:"<p>Les utilisateurs front-office et back-office sont regroupés au sein d'un annuaire interne. Les droits accordés à un utilisateur sont liés aux groupes auxquels il appartient.L'application \"Utilisateurs\" permet  :</p><ul><li> d'ajouter des utilisateurs</li> <li> de compléter les profils (email, service, fonction, photo, ...)</li> <li>  de gérer les accès et les droits (identifiant, mot de passe, groupes, validité du compte)</li> </ul> ",
        contents:"<p>Rubedo gère un référentiel transverse de contenus qui peuvent être publiés sur différents sites et espaces de travail.L'application \"Contenus\" permet  :</p><ul><li> de créer un contenu à partir d'un type de contenu paramétré</li> <li>  de gérer son état dans le workflow de publication attribué au type de contenu</li> <li>  de gérer la publication différée</li> <li>  de classer le contenu à l'aide des vocabulaires autorisés pour ce type de contenu</li> <li>  d'associer le contenu à un espace de contribution et des espaces de diffusion</li> <li>  de modifier les contenus</li> <li>  de dupliquer les contenus</li> <li>  d'ajouter un contenu en favori</li> </ul> ",
        dam:"<p>La médiathèque permet de gérer les médias ( images, vidéo, audio, animation ou documents) en fonction des types de médias paramétrés.L'application \"Médiathèque\" permet  :</p><ul><li> de créer un média à partir d'un type de média paramétré</li><li>  d'uploader un média et de renseigner les métadonnées associées</li><li>  de classer le média à l'aide des vocabulaires autorisés pour ce type de média</li><li>  d'associer le média à un espace de contribution et des espaces de diffusion</li><li>  de modifier les média</li><li>  d'ajouter un média en favori</li></ul>",
        forms:"<p>Rubedo permet de réaliser des enquêtes en ligne à l'aide de l'application questionnaire. Les fonctions de glisser/déposer facilitent la création des questions et des étapes. L'application Questionnaire permet :</p><ul><li> d'ajouter, supprimer et dupliquer un questionnaire</li><li> d'ajouter un questionnaire en favoris</li><li> de gérer les propriétés d'un questionnaire,  les conditions d'unicité et sa mise en ligne</li><li> de créer un questionnaire à l'aide des palettes d'outils de mise en forme (Wysiwyg, image, section, page, titre) et de paramétrage (type de questions)</li><li> de gérer les paramétres des questions et des réponses (label, bulle d'aide, obligatoire, conditionnel et options)</li><li> d'exploiter les résultats de chaque questionnaire en exportant au format csv</li></ul>"
        };
        var defaultAutomatedElementsLoc={
        notifTitle:"Notififcation",
        notifCreate:"<p>Création réussie.</p>",
        notifUpdate:"<p>Mise à jour réussie.</p>",
        notifDestroy:"<p>Suppression réussie.</p>",
        errorTitle:"Erreur",
        serverConnectionError:"Connexion au serveur interrompue",
        internalServerError:"Erreur interne du serveur",
        unkownError:"Erreur inconnue",
        activateText:"Activer",
        pageHoldsDefaultError:"Cette page ne peut etre suprimée car elle u une de ses décendantes est utilisée comme page de détail du site",
        pageHoldsDefaultServerError:"Erreur dans la détermination du statut supprimable de la page",
        deactivateText:"Désactiver",
        windowBeforeUnloadMessage:"Vous allez quitter le Back Office et perdre toute modification non sauvegardée.",
        maskIsUsedText:"Le masque ne peut etre supprimé car il est utilisé par des pages.",
        selectAnElementText:"Sélectionnez un élément",
        columnText:"Colonne",
        lignText:"Ligne",
        titleText:"Titre",
        displayTitleText:"Afficher le titre",
        visibilityText:"Visibilité",
        telephoneText:"Téléphone",
        tabletText:"Tablette",
        computerText:"Ordinateur",
        HTMLClassText:"Classe HTML",
        HTMLIdText:"Id HTML",
        styleText:"Style",
        tagText:"Tag",
        displayAsTabsText:"Afficher en onglets",
        displayRowTagText:"Afficher la baliser row",
        displayRowFluidTagText:"Afficher la balise row-fluid",
        includeInAContainerText:"Inclure dans un container",
        includeInAContainerFluidText:"Inclure dans un container-fluid",
        containerIdText:"Id du container",
        containerClassText:"Classe du container",
        mainColumnText:"Colonne principale",
        mainColumnRTip:"Permet de définir l'emplacement d'affichage des contenus proposés sous forme de liste dans les pages utilisants ce masque.",
        showSpanAndOffsetText:"Afficher le span et l'offset",
        offsetText:"Offset",
        spanText:"Span",
        columnIdRecoveryError:"Erreur dans la récupération d\'un identifiant de colonne",
        displayInADivText:"Afficher dans une div",
        divIdText:"Id de la div",
        divClassText:"Classe de la div",
        blockText:"Bloc",
        URLPrefixText:"Préfixe URL",
        invalidMetaError:"Certains champs de métadonnées sont invalides.",
        invalidTaxoError:"Certains champs de taxonomie sont invalides.",
        invalidFieldsError:"Certains champs sont invalides.",
        insufficientContentRightsError:"Vos droits sont insuffisants pour afficher ou modifier ce contenu",
        newContentText:"Nouveau Contenu",
        maxOneLocFieldError:"Un type de contenus ne peut pas avoir plusieurs champs de type \"Localisation\".",
        contentTypeIsUsedError:"Ce type de contenu est utilsé par des contenus et ne peut donc pas etre supprimé.",
        warningTitle:"Attention",
        contentTypeIncompatModifError:"Le type de contenu est utilisé par des contenus et ces modifications ne sont pas compatibles.",
        contentTypeModifWarning:"Ce type de contenu est utilisé par des contenus. Le modifier pourrait avoir de répercussions. </br> Souhaitez-vous continuer ?",
        fieldReplicaText:"Replique du champ",
        successTitle:"Succés",
        contentsDeleteError:"Erreur dans la suppression des contenus",
        contentTypeHasBeenEmptiedText:"Le type de contenu a été vidé",
        fieldNameAlreadyUsedError:"Nom dèjà utilisé par un autre champ",
        passwordsDoNotMatchError:"Les mots de passe ne correspondent pas",
        passwordChangedText:"Mot de passe changé",
        rightsRecoveryError:"Erreur dans la récupération des droits",
        tokenRecoveryError:"Erreur dans la récupération du jeton de sécurité",
        siteModifWarning:"La modification de ce site impliquera la fermeture de la fenetre de gestion des pages. Cela entrainera la perte de toute modification non sauvegardée dans cette fenetre. </br> Souhaitez-vous poursuivre ?",
        pageURLRecoveryError:"Erreur dans la récupèration de l'url de la page",
        pagePreviewText:"Ceci est un aperçu de cette page telle que disponible en ligne en",
        associatedMaskText:"Masque associé",
        pagePropertiesInvalidError:"Les propriétés de la page sont invalides.",
        stageText:"Etape",
        onText:"sur",
        ascText:"Croissant",
        descText:"Decroissant",
        andText:"Et",
        thenText:"Puis",
        mediaTypeIsUsedError:"Ce type de média est utilisé par des médias et ne peut donc etre supprimé.",
        invalidRightsPropertiesError:"Configuration invalide des droits",
        newDamText:"Nouveau média",
        DAMEditText:"Edition du média",
        DAMDisplayText:"Affichage du média",
        searchText:"Recherche",
        identifierRecoveryError:"Erreur dans la récupération d'un identifiant",
        invalidFormPropertiesError:"Propriétés du formulaire invalides",
        fileAnalysisError:"Erreur dans l'analyse du fichier",
        identifiedFieldsText:"champs identifiés et",
        importableContentsText:"contenus importables",
        importedContentsText:"contenus importés",
        importError:"Erreur lors de l'import",
        eligibleContentTypesText:"Types de contenus eligibles",
        eachContentMustVerifyRulesText:"Chaque contenu doit verifier les règles suivantes",
        eachContentMustVerifyAtLeastOneRuleText:"Chaque contenu doit verifier au moins une des règles suivantes",
        taxonomyText:"Taxonomie",
        rulesAndSortsOnFieldsText:"Règles et tris sur les champs des contenus",
        ascSortText:"tri croissant",
        descSortText:"tri decroissant",
        relationBetweenRulesText:"Relation entre les règles",
        creationText:"Création",
        lastUpdateText:"Dernière modification",
        noVocabForTheseCtText:"Pas de vocabulaire disponible pour cet ensemble de types de contenus",
        ruleText:"Règle",
        tRuleAllText:"Contient tous les termes",
        tRuleAllRecText:"Contient tous les termes ou au moins un descendant par terme",
        tRuleSomeText:"Contient au moins un des termes",
        tRuleSomeREcText:"Contient au moins un des termes ou au moins un des descendants d’un des termes",
        tRuleNotText:"Ne contient aucun des termes suivants",
        tRuleNotRecText:"Ne contient ni les termes suivants ni leurs descendants",
        CTMustHaveTitleError:"Le type de contenu doit obligatoirement avoir un champ de type \"Titre\"",
        CTMustHaveOnlyOneTitleError:"Le type de contenu ne doit avoir qu'un seul champ de type \"Titre\"",
        CTMustHaveOnlyOneSummaryError:"Le type de contenu ne doit avoir qu'un seul champ de type \"Résumé\"",
        CRMustHaveOnlyOneLocFieldError:"Le type de contenu ne doit avoir qu'un seul champ de type \"Localisation\"",
        notMentionedText:"non renseigné",
        showOnlyIfText:"Affiché si et seulement si",
        orText:"Ou",
        rootText:"Racine",
        esGeoQueryText:"Assistant de requête Elastic Search geolocalisée",
        esQueryText:"Assistant de requête Elastic Search",
        esDAMQueryText:"Assistant de requête DAM Elastic Search",
        keywordsText:"Mots-clés",
        defaultKeywordsText:"Mots-clés par défaut",
        defaultSinglePageText:"Page de détail par défaut",
        homePageText:"Page d'accueil",
        rolesText:"Rôles"
        };
        var defaultInterfaceLoc=me.produceInterfaceLocalisationJSON();
        var store=Ext.getStore("LocalisationStore");
        var helpRec=store.findRecord("name","RubedoAppHelp");
        store.suspendAutoSync();
        if (Ext.isEmpty(helpRec)){
        store.add({name:"RubedoAppHelp",items:defaultHelp,i18n:{}});
        } else {
        helpRec.set("items",defaultHelp);
        }

        var intLocRec=store.findRecord("name","RubedoInterfaceLoc");
        if (Ext.isEmpty(intLocRec)){
        store.add({name:"RubedoInterfaceLoc",items:defaultInterfaceLoc,i18n:{}});
        } else {
        intLocRec.set("items",defaultInterfaceLoc);
        }
        var autoElsLoc=store.findRecord("name","RubedoAutomatedElementsLoc");
        if (Ext.isEmpty(autoElsLoc)){
        store.add({name:"RubedoAutomatedElementsLoc",items:defaultAutomatedElementsLoc,i18n:{}});
        } else {
        autoElsLoc.set("items",defaultAutomatedElementsLoc);
        }
        store.resumeAutoSync();
        store.sync();
        console.log("Done saving localisation. Please reload the page.");*/
    },

    extractLocFromBlocksJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("BlocsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.configBasique.title=me.insertAndReplace(extractedLoc, block.configBasique.title);
            Ext.Array.forEach(block.configBasique.champsConfig.simple, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
            Ext.Array.forEach(block.configBasique.champsConfig.avance, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFormFieldsJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("FormFieldTypesStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            if (!Ext.isEmpty(block.itemConfig.label)){
                block.itemConfig.label=me.insertAndReplace(extractedLoc, block.itemConfig.label);
            }
            if (!Ext.isEmpty(block.itemConfig.html)){
                block.itemConfig.html=me.insertAndReplace(extractedLoc, block.itemConfig.html);
            }


        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFTJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("TypesChampsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.config.fieldLabel=me.insertAndReplace(extractedLoc, block.config.fieldLabel);
            Ext.Array.forEach(block.configFields, function(field){
                field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
            });

        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    insertAndReplace: function(locObj, targetString) {
        var newId="#"+Ext.id()+"#";
        var finalId=Ext.clone(newId);
        Ext.Object.each(locObj, function(key, value, myself) {
            if (value==targetString){
                finalId=key;
            }
        });
        if (newId==finalId){
            locObj[finalId]=targetString;
        }
        return(finalId);
    }

});
