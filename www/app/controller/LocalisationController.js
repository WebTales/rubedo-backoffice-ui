/*
 * File: app/controller/LocalisationController.js
 *
 * This file was generated by Sencha Architect version 3.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Rubedo.controller.LocalisationController', {
    extend: 'Ext.app.Controller',
    alias: 'controller.LocalisationController',

    models: [
        'LocalisationModel'
    ],
    stores: [
        'LocalisationStore'
    ],

    onButtonAfterRender1: function(component, eOpts) {
        try {
            component.on("click", function(){
                Ext.widget('callout', {
                    cls: 'gray',
                    width: 400,
                    html:Rubedo.RubedoAppHelp[component.RApplication],
                    calloutArrowLocation: 'top-right',
                    target: component,
                    relativePosition: 't-b',
                    relativeOffsets: [-184,0],
                    fadeInDuration: 200,
                    fadeOutDuration: 200,
                    dismissDelay: 60000
                }).show();

            });
        } catch (err){
            console.log("failed to show application help");
        }
    },

    onComponentBeforeRender: function(component, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
                if (!Ext.isEmpty(configs.tooltip)) {
                    component.setTooltip(configs.tooltip);
                }
            }
            if ((component.isXType("button"))&&(component.scale=="large")&&(Ext.isEmpty(component.dontStretch))){
                component.minWidth=48;
            }
        }
        if ((component.isXType("field"))||(component.isXType("checkboxgroup"))||(component.isXType("radiogroup"))){
            component.labelSeparator=" ";
        }
    },

    onBasefieldAdded: function(component, container, pos, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
            }
        }
        if (!Ext.isEmpty(component.RTip)){
            component.anchor="90%";
            container.insert(pos,Ext.widget("RHelpBtn", {tooltip:component.RTip}));
        }
    },

    onFieldsetAfterRender: function(component, eOpts) {
        var task = new Ext.util.DelayedTask(function(){
            component.setTitle(component.title);
        });
        task.delay(100);
    },

    onWorkingLanguageFieldChange: function(field, newValue, oldValue, eOpts) {
        var myBtn=Ext.getCmp("workingLanguageBtn");
        if (Ext.isEmpty(newValue)){
            myBtn.setIcon(null);
            myBtn.setIconCls("infoWarning");
            myBtn.setTooltip(Rubedo.RubedoAutomatedElementsLoc.noCurrentWorkingLanguageError);
            myBtn.setText(null);
        } else {
            var myRec=Ext.getStore("AllLanguagesStore3").query("locale",newValue,false,false,true).items[0];
            myBtn.setIconCls(null);
            myBtn.setIcon('/assets/flags/16/'+myRec.get("flagCode")+'.png');
            myBtn.setTooltip(Rubedo.RubedoAutomatedElementsLoc.currentWorkingLanguageText+" : "+myRec.get("label"));
            myBtn.setText(myRec.get("label"));
            if (!Ext.isEmpty(myRec.get("ownLabel"))){
                myBtn.setText(myRec.get("ownLabel"));
            }
        }
    },

    onEnteteAfterRender: function(component, eOpts) {
        var task = new Ext.util.DelayedTask(function(){
            component.remove(Ext.getCmp("ESSearchField"));
            component.insert(8, Ext.widget("ESSearchField"));
            Ext.getCmp("desktopHomeBtn").setTooltip(Rubedo.RubedoAutomatedElementsLoc.showDesktopTooltip);
        });
        task.delay(600);

    },

    onWorkingLanguageBtnClick: function(button, e, eOpts) {
        //Ext.widget("workingLanguageChangeWindow").show();
    },

    onCurrentLanguageChangeSubmitBtnClick: function(button, e, eOpts) {
        var form=button.up().getForm();
        if (form.isValid()){
            Ext.getCmp("workingLanguageField").setValue(form.getValues().language);
            Ext.getStore("CurrentUserDataStore").getRange()[0].set("workingLanguage",form.getValues().language);
            button.up().up().close();
        }
    },

    init: function(application) {
                var me=this;
                Ext.override(Ext.form.field.Date, {
                    submitFormat:'U',
                    altFormats:'U|m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j'
                });
                Ext.override(Ext.form.field.Number, {
                    getSubmitValue: function(){return(this.getValue());}
                });
                Ext.require("Ext.ux.callout.Callout");

                Ext.Date.defaultFormat="d/m/Y";
                //define localisation singletons
                Ext.define("Rubedo.RubedoAppHelp",{
                    singleton:true,
                    "pages": "<p>The different pages of a site can easily be enriched with functional blocks.The 'Pages' application allows:</p> <ul><li>to access the tree view of sites maintained on the platform,</li> <li>to add pages based on existing pages masks</li> <li>to modify or delete pages,</li> <li> to add functionalities to pages through the library of functional blocks</li> <li>to preview the display of a page in front-office,</li> <li>to manage SEO settings,</li> <li>to manage reading and writing rights through workspaces.</li></ul>",
                    "sites": "<p>Rubedo natively offers the site building feature.The 'Sites' application allows:</p> <ul><li>to create new sites through a wizard</li> <li>on the basis of existing models or from a blank template</li> <li>to modify the settings of existing sites</li></ul>",
                    "masks": "<p>Pages masks represent the different rendering templates available in front office.The \"Page masks\" application allows:</p> <ul><li>to create new layout templates in rows and columns</li> <li>to duplicate existing masks, possibly from one site to another</li> <li>to manage the persistent functional blocks, such as menus</li> <li>to form a library of elements (rows, columns, or blocks) that is reusable between masks</li> <li>to manage Responsive Design settings : visibility of rows, columns and blocks on phone, tablet, or desktop</li></ul>",
                    "contentTypes": "<p>Content types correspond to the structured data managed by Rubedo: articles, news,.. .etc. The 'Content Types' application allows :</p> <ul><li>to create new content types using an advanced editor</li> <li>to set up input controls, default values, mandatory state for each field</li> <li>to modify existing content types</li> <li>to manage localizable (several language), and searchable state of each field</li> <li>to manage input aid</li> <li>to declare vocabularies applicable to the classification of the contents</li> <li>to choose the workflow to apply to contents</li> <li>to declare read and write workspaces for contents</li></ul>",
                    "damTypes": "<p>Digital asset types correspond to Rubedo-managed files: images, video, audio, animation or documents.'Digital Asset Types' application allows:</p> <ul><li>to create new digital asset types (image, document, video, audio, animation)</li> <li>to add metadata (author, copyright, caption, etc) using an advanced editor</li> <li>to set input controls, default values, mandatory state for each field</li> <li>to edit existing digital asset types</li> <li>to manage localizable(several language) and searchable state for each field</li> <li>to manage input aid</li> <li>to choose vocabularies eligible as classification</li> <li>to declare read and write workspaces</li></ul>",
                    "queries": "<p>Queries are used to create automatic or manual lists of contents and digital assets.The \"Queries\" application allows:</p> <ul><li>to create and save simple or advanced, content or digital asset queries</li> <li>to edit or remove existing queries</li> <ul>",
                    "taxonomy": "<p>Taxonomy alows for the creation of a multi-dimensional classification of contents and digital assets.The \"Taxonomy\" application allows:</p> <ul><li>to create new vocabularies and add terms using a tree</li> <li>to apply rights for workspaces and inpu aid for each vocabulary</li> <li>to define vocabulary settings: expandable, multi-choice, mandatory</li></ul>",
                    "groups": "<p>Groups are used to associate users with rights in the form of workspaces and roles.The 'Groups' application allows:</p> <ul><li>to create groups of users</li> <li>to add users to these groups</li> <li>to set up the rights associated with each group: workspaces (read, write, default) and roles</li> <li>to manage groups (deletion, modification, inheritance)</li></ul>",
                    "workspaces": "<p>Workspaces are used to restrict access (read, write or broadcast) on content, digital asset types or sites topics to specific user groups.The 'Workspaces' application allows:</p> <ul><li>to create workspaces</li> <li>to delete or edit workspaces</li></ul>",
                    "users": "<p>Front-office and back-office users are grouped in an internal directory. The rights granted to a user are linked to groups to which he belongs.The 'Users' application allows:</p> <ul><li>to add users</li> <li>to complete profiles (email, service, job title, photo,...)</li> <li>to manage  access and rights (identifier, password, groups, account validityt)</li></ul> ",
                    "contents": "<p>Rubedo manages a transverse repository of content that can be published on different sites and workspaces.The \"Contents\" application allows:</p> <ul><li>to create contents using an existing content type</li> <li>to manage its status in the workflow of publication attributed to the content type</li> <li>to manage delayed publication</li> <li>to classify content using vocabularies allowed for this contnet type</li> <li>to associate contents to contribution and diffusion workspaces</li> <li>to modify contents</li> <li>to duplicate contents</li> <li>to add contents to favorites</li></ul> ",
                    "dam": "<p>The DAM allows you to manage digital assets (images, video, audio, animation or documents) based on predefined digital asset types.The \"DAM\" application allows:</p> <ul><li>to create digital assets using existing digital asset types</li> <li>to upload digital assets and apply metadata settings</li> <li>to classify digital assets using vocabularies allowed for this digital asset type</li> <li>to set up contributionand diffusion workspaces </li> <li>to edit digital assets</li> <li>to add digital assets to favorites</li></ul>",
                    "forms": "<p>This application is used to conduct online surveys. Stages and questions can be easly created and manged through drag and drop. The \"Surveys\" application allows:</p> <ul><li>to add, edit, delete, and duplicate a survey</li> <li>to add a survey to favorites</li> <li>to manage the settings and unique answer conditions of a survey and put it online</li> <li>to create a survey using the tool palette of formatting (Wysiwyg, image, section, page, title) and settings (type of questions and their specific settings)</li> <li>to manage questions and answers (label settings(, input aid, mandatory state, conditionals, and options)</li> <li>to exploit the results of each survey by exporting to CSV format</li></ul>"

                });
                Ext.define("Rubedo.RubedoInterfaceLoc",{
                    singleton:true
                });
                Ext.define("Rubedo.RubedoAutomatedElementsLoc",{
                    singleton:true,
                    "notifTitle": "Notification",
                    "notifCreate": "<p>Successful creation.</p>",
                    "notifUpdate": "<p>Successful update.</p>",
                    "notifDestroy": "<p>Successful deletion.</p>",
                    "errorTitle": "Error",
                    "serverConnectionError": "Server connection interrupted",
                    "internalServerError": "Internal server error",
                    "unkownError": "Unknown error",
                    "activateText": "Activate",
                    "pageHoldsDefaultError": "This page cannot be deleted because it or one of its decendantes is the homepage or the detail page",
                    "pageHoldsDefaultServerError": "Error in the determination of the deletable status of the page",
                    "deactivateText": "Disable",
                    "windowBeforeUnloadMessage": "You will leave the Back Office and lose any unsaved changes.",
                    "maskIsUsedText": "The mask cannot be deleted because it is used by pages.",
                    "selectAnElementText": "Select an item",
                    "columnText": "Column",
                    "lignText": "Line",
                    "titleText": "Title",
                    "displayTitleText": "Display the title",
                    "visibilityText": "Visibility",
                    "telephoneText": "Phone",
                    "tabletText": "Tablet",
                    "computerText": "Desktop",
                    "HTMLClassText": "HTML class",
                    "HTMLIdText": "HTML ID",
                    "styleText": "Style",
                    "tagText": "Tag",
                    "displayAsTabsText": "Display in tabs",
                    "displayRowTagText": "Display the row tag",
                    "displayRowFluidTagText": "Show row-fluid tag",
                    "includeInAContainerText": "Include in a container",
                    "includeInAContainerFluidText": "Include in a fluid container",
                    "containerIdText": "ID of the container",
                    "containerClassText": "Container class",
                    "mainColumnText": "Main column",
                    "mainColumnRTip": "Sets the display location for content detail in pages using this mask.",
                    "showSpanAndOffsetText": "Display the span and offset",
                    "offsetText": "Offset",
                    "spanText": "Span",
                    "columnIdRecoveryError": "Error in the recovery of a column identifier",
                    "displayInADivText": "Display in a div",
                    "divIdText": "ID of the div",
                    "divClassText": "The div class",
                    "blockText": "Block",
                    "URLPrefixText": "URL Prefix",
                    "invalidMetaError": "Some metadata fields are invalid.",
                    "invalidTaxoError": "Some taxonomy fields are invalid.",
                    "invalidFieldsError": "Some fields are invalid.",
                    "insufficientContentRightsError": "You have insufficient rights to view or modify this content",
                    "newContentText": "New content",
                    "maxOneLocFieldError": "A content type cannot have multiple fields of type \"Location\".",
                    "contentTypeIsUsedError": "This content type is used by content and therefore cannot be deleted.",
                    "warningTitle": "Warning",
                    "contentTypeIncompatModifError": "The content type is used by content and these amendments are not compatible.",
                    "contentTypeModifWarning": "This content type is used by content. Changing it could have repercussions. </br> Would you like to continue?",
                    "fieldReplicaText": "Replica of the field",
                    "successTitle": "Success",
                    "contentsDeleteError": "Error in deleting content",
                    "contentTypeHasBeenEmptiedText": "The content type has been emptied",
                    "fieldNameAlreadyUsedError": "Name already used by another field",
                    "passwordsDoNotMatchError": "Passwords don't match",
                    "passwordChangedText": "Password changed",
                    "rightsRecoveryError": "Error in the recovery of the rights",
                    "tokenRecoveryError": "Error in retrieving the security token",
                    "siteModifWarning": "The modification of this site will involve the closing of the page management window. This will result in the loss of any changes not saved in that window. </br> Do you want to continue?",
                    "pageURLRecoveryError": "Error in retrieving the url of the page",
                    "pagePreviewText": "This is an overview of this page as available online on",
                    "associatedMaskText": "Associated mask",
                    "pagePropertiesInvalidError": "The properties of the page are invalid.",
                    "stageText": "Step",
                    "onText": "out of",
                    "ascText": "Ascending",
                    "descText": "Descending",
                    "andText": "And",
                    "thenText": "Then",
                    "mediaTypeIsUsedError": "This type of media is used by media and therefore cannot be deleted.",
                    "invalidRightsPropertiesError": "Invalid rights configuration",
                    "newDamText": "New media",
                    "DAMEditText": "Edition of the media",
                    "DAMDisplayText": "Display of the media",
                    "searchText": "Search",
                    "identifierRecoveryError": "Error in the recovery of an identifier",
                    "invalidFormPropertiesError": "Invalid form properties",
                    "fileAnalysisError": "Error in parsing the file",
                    "identifiedFieldsText": "identified fields and",
                    "importableContentsText": "importable contents",
                    "importedContentsText": "contents imported",
                    "importError": "Error during import",
                    "eligibleContentTypesText": "Eligible content types",
                    "eachContentMustVerifyRulesText": "Each content must verify the following rules",
                    "eachContentMustVerifyAtLeastOneRuleText": "Each content must verify at least one of the following rules",
                    "taxonomyText": "Taxonomy",
                    "rulesAndSortsOnFieldsText": "Rules and sorting on content fields",
                    "ascSortText": "Sort ascending",
                    "descSortText": "sort descending",
                    "relationBetweenRulesText": "Relationship between the rules",
                    "creationText": "Creation",
                    "lastUpdateText": "Last modified",
                    "noVocabForTheseCtText": "No vocabulary available for this set of content types",
                    "ruleText": "Rule",
                    "tRuleAllText": "Contains all the terms",
                    "tRuleAllRecText": "Contains all the terms or at least a descendant per term",
                    "tRuleSomeText": "Contains at least one of the terms",
                    "tRuleSomeREcText": "Contains at least one of the terms or at least one of the descendants of one of the terms",
                    "tRuleNotText": "Does not contain any of the following terms",
                    "tRuleNotRecText": "Does not contain the following terms or their descendants",
                    "CTMustHaveTitleError": "The content type must have a 'Title' field",
                    "CTMustHaveOnlyOneTitleError": "The content type must have only a single field of type \"title\"",
                    "CTMustHaveOnlyOneSummaryError": "The content type must have only a single field of type \"Summary\"",
                    "CRMustHaveOnlyOneLocFieldError": "The content type must have only a single field of type 'Location'",
                    "notMentionedText": "not filled",
                    "showOnlyIfText": "Displayed if and only if",
                    "orText": "Or",
                    "rootText": "Root",
                    "esGeoQueryText": "Geolocated Elastic Search Query Wizard",
                    "esQueryText": "Elastic Search Query Wizard",
                    "esDAMQueryText": "DAM Elastic Search Query Wizard",
                    "keywordsText": "Keywords",
                    "defaultKeywordsText": "Default keywords",
                    "defaultSinglePageText": "Default detail page",
                    "homePageText": "Homepage",
                    "rolesText": "Roles",
                    "authorText": "Author",
                    "versionText": "Version",
                    "contentsText": "Contents",
                    "displayText": "Display",
                    "publishedText": "published",
                    "pendingText": "pending validation",
                    "draftText": "draft",
                    "refusedText": "refused",
                    "yesText": "Yes",
                    "noText": "No",
                    "mediasText": "Media",
                    "simpleQueryText": "Simple query",
                    "manualQueryText": "Manual query",
                    "restoreText": "Restore",
                    "originalFileMText": "Original file *",
                    "noneText": "None",
                    "basicText": "Basic",
                    "formUniqueAnswerMessage": "You have already completed this survey. Thank you.",
                    "formEndMessage": "Thank you for completing this survey.",
                    "oldVersionText": "(A more recent version of Rubedo is available)",
                    "summaryText": "Summary",
                    "showDesktopTooltip": "Show desktop",
                    "userText":"user",
                    "usersText":"users",
                    "emptyText":"empty",
                    "groupsText":"Groups",
                    "removeText":"Remove",
                    "duplicateFieldText":"Duplicate of the field",
                    "duplicateText":"Duplicate",
                    "multivaluedText":"Multivalued",
                    "searchableText":"Searchable",
                    "localizableText":"Localizable",
                    "optionalText":"Optional",
                    "fileTypeText":"File type",
                    "tooltipText":"Tooltip",
                    "nameText":"Name",
                    "labelText":"Label",
                    "fileFieldText":"File",
                    "fileFieldDescription":"<h2>File field<\/h2> <\/br> <p>This field allows for the upload of files.<\/p>",
                    "databaseIsUpToDateText":"Database is up to date",
                    "databaseNeedsUpdateText":"Database update required",
                    "databaseUpdateWarning":"This action will update the Rubedo database. It is recommended that you back-up your data before starting. Would you like to continue ?",
                    "databaseUpdatedToText":"The database has been updated to version",
                    "folderViewText":"Folder view",
                    "switchToFolderViewText": "Switch to folder view",
                    "searchViewText":"Search view",
                    "switchToSearchViewText":"Switch to search view",
                    "notFiledText": "Not filed",
                    "mediaTypeText":"Media type",
                    "filesUploadedText":"files uploaded",
                    "allText":"All",
                    "contentTypeText":"Content type",
                    "encodingText":"Encoding",
                    "siteLanguageChoiceError":"The default site language must be one of the site languages",
                    "delconBaseText":"Are you sure you want to delete",
                    "thisMaskText":"this page mask",
                    "thisPageText": "this page",
                    "thisContentTypeText":"this content type",
                    "thisMediaTypeText":"this media type",
                    "thisSurveyText":"this survey",
                    "thisFolderText":"this folder",
                    "thisMediaText":"this digital asset",
                    "thisVocabularyText":"this vocabulary",
                    "atLeastOneLocError":"At least one language must be active",
                    "alreadyTranslatedError":"This item has already been translated in all active languages",
                    "missingLocError":"This version is not eligible for localized revert",
                    "imageRequiredError":"An image must be selected",
                    "localizationErrorText":"Localization error",
                    "noCurrentWorkingLanguageError":"No working language selected",
                    "currentWorkingLanguageText":"Current working language",
                    "languagesText":"Languages",
                    "locStrategyText":"Localizastion strategy",
                    "useBrowserLanguageText":"Use browser language",
                    "onlyOneText":"Only one",
                    "withFallbackText":"With fallback",
                    "editText":"Edit",
                    "alreadyAnsweredText":"Already answered",
                    "MediaFieldNeedsTypeError":"Media fields require a media type",
                    "damTypeHasBeenEmptiedText": "The media type has been emptied",
                    "themePreviewText":"Theme preview",
                    "fieldText":"Field",
                    "dbclickToAssignText":"Double-click available fields to assign to this column",
                    "boReloadRequired":"This change requires an interface reload in order to fully take effect. Would you like to reload now ?",
                    "thisUserTypeText":"this user type",
                    "userTypeIsUsedError":"This user type is used by users and therfore cannot be deleted.",
                    "widthText":"Width",
                    "centeredText":"Centered",
                    "bgColorText":"Background color",
                    "bbgColorText":"Body background color",
                    "imageText":"Image",
                    "textText":"Text",
                    "emailBodyText":"Email body",
                    "emailSendWarning":"Are you sure you want to send this email to all users subscribed to the selected mailing list ?",
                    "modelText":"Model",
                    "mailText":"Mail",
                    "displayLabelText":"Display label",
                    "productTypeText":"ProductType",
                    "configurableText":"Configurable",
                    "productsText":"Products",
                    "updateText":"Update",
                    "neverText":"Never",
                    "largeDesktopText":"Large desktop",
                    "customTemplateText":"Custom template",
                    "displayAsTabsText":"Display as tabs",
                    "stackingThresholdText": "Stacking threshold",
                    "cancelledText":"Cancelled",
                    "pendingPaymentText":"Pending payment",
                    "payedText":"Payed"
                });

        this.control({
            "#RHelpBtn": {
                afterrender: this.onButtonAfterRender1
            },
            "component": {
                beforerender: this.onComponentBeforeRender
            },
            "field, checkboxgroup, radiogroup": {
                added: this.onBasefieldAdded
            },
            "fieldset": {
                afterrender: this.onFieldsetAfterRender
            },
            "#workingLanguageField": {
                change: this.onWorkingLanguageFieldChange
            },
            "#entete": {
                afterrender: this.onEnteteAfterRender
            },
            "#workingLanguageBtn": {
                click: this.onWorkingLanguageBtnClick
            },
            "#currentLanguageChangeSubmitBtn": {
                click: this.onCurrentLanguageChangeSubmitBtnClick
            }
        });
    },

    produceInterfaceLocalisationJSON: function() {
        var result= { };
        var count=0;
        Ext.Object.each(Rubedo.view, function(a){
            try{
                var test=Ext.create("Rubedo.view."+a,{id:undefined});
                if (!Ext.isEmpty(test.localiserId)){
                    count=count+1;
                    if ((test.isXType("field"))||(test.isXType("radiogroup"))||(test.isXType("checkboxgroup"))){
                        result[test.localiserId]={
                            fieldLabel:test.fieldLabel,
                            boxLabel:test.boxLabel,
                            buttonText:test.buttonText,
                            RTip:test.RTip
                        };
                    } else if (test.isXType("button")){
                        result[test.localiserId]={
                            text:test.text,
                            tooltip:test.tooltip
                        };
                    } else if (test.isXType("menuitem")){
                        result[test.localiserId]={
                            text:test.text,
                            tooltip:test.tooltip
                        };
                    }else if (test.isXType("fieldset")){
                        result[test.localiserId]={
                            title:test.title
                        };
                    } else if (test.isXType("panel")){
                        result[test.localiserId]={
                            title:test.title,
                            tooltip:test.tooltip
                        };
                    } else if (test.isXType("window")){
                        result[test.localiserId]={
                            title:test.title
                        };
                    }else if (test.isXType("gridcolumn")){
                        result[test.localiserId]={
                            text:test.text
                        };
                    } else {
                        console.log("unhandled localised component for id : "+test.localiserId);
                        count=count-1;
                    }
                    if (!Ext.isEmpty(result[test.localiserId])){
                        Ext.Object.each(result[test.localiserId], function(key, value, myself) {
                            if (Ext.isEmpty(value)){
                                delete result[test.localiserId][key];
                            }
                        });
                    }
                }
                try{
                    Ext.Array.forEach(test.query("component"), function(component){
                        if (!Ext.isEmpty(component.localiserId)){
                            count=count+1;
                            if ((component.isXType("field"))||(component.isXType("radiogroup"))||(component.isXType("checkboxgroup"))){
                                result[component.localiserId]={
                                    fieldLabel:component.fieldLabel,
                                    boxLabel:component.boxLabel,
                                    buttonText:component.buttonText,
                                    RTip:component.RTip
                                };
                            } else if (component.isXType("button")){
                                result[component.localiserId]={
                                    text:component.text,
                                    tooltip:component.tooltip
                                };
                            } else if (component.isXType("menuitem")){
                                result[component.localiserId]={
                                    text:component.text
                                };
                            }else if (component.isXType("fieldset")){
                                result[component.localiserId]={
                                    title:component.title
                                };
                            } else if (component.isXType("panel")){
                                result[component.localiserId]={
                                    title:component.title,
                                    tooltip:component.tooltip
                                };
                            } else if (component.isXType("window")){
                                result[component.localiserId]={
                                    title:component.title
                                };
                            }else if (component.isXType("gridcolumn")){
                                result[component.localiserId]={
                                    text:component.text
                                };
                            } else {
                                console.log("unhandled localised component for id : "+component.localiserId);
                                count=count-1;
                            }
                            if (!Ext.isEmpty(result[component.localiserId])){
                                Ext.Object.each(result[component.localiserId], function(key, value, myself) {
                                    if (Ext.isEmpty(value)){
                                        delete result[component.localiserId][key];
                                    }
                                });
                            }
                        }
                    });

                }catch(err){
                    console.log(err);
                }
                try{
                    test.destroy();
                }catch(err){console.log("destroy anomaly");}
                }catch(err){console.log("loc anomaly");}
                });
                console.log(count+" localised interface components");
                return(Ext.JSON.encode(result));
    },

    updateLocalisationSingletons: function() {
        var userLanguage=Ext.getStore("CurrentUserDataStore").getRange()[0].get("language");
        if (Ext.isEmpty(userLanguage)){
            userLanguage="en";
        }
        if (userLanguage=="en"){
            Ext.Date.defaultFormat="m/d/Y";
        }
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/appHelp.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAppHelp, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAppHelp singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/componentLabels.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoInterfaceLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoInterfaceLoc singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/automatedElements.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAutomatedElementsLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAutomatedElementsLoc singleton could not be localized for the current language");
            }
        });
        if (!Ext.isEmpty(Ext.getStore("TypesChampsDataStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/fieldTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/fieldTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("TypesChampsDataStore").removeAll();
                            Ext.getStore("TypesChampsDataStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("FieldTypes store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("FieldTypes store could not retrieve generic structure");
                }
            });
        }
        if (!Ext.isEmpty(Ext.getStore("BlocsDataStore"))){
            Ext.Ajax.request({
                url: 'blocks',
                method:'GET',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/blockTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                        Ext.Array.forEach(decodedFT,function(candidateBlock){
                            if (Ext.isEmpty(candidateBlock)){
                            	Ext.Array.remove(decodedFT,candidateBlock);
                            }
                        });
                            Ext.getStore("BlocsDataStore").removeAll();
                            Ext.getStore("BlocsDataStore").loadData(decodedFT);
                            var task6 = new Ext.util.DelayedTask(function(){
                                if (!PHPOptions.addECommerce){
                                    Ext.getStore("BlocsDataStore").filter("isECommerce",false);
                                }
                            });
                            task6.delay(400);


                        },
                        failure:function(){
                            console.log("Blocks store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("Blocks store could not retrieve generic structure");
                }
            });
        }

        this.correctLanguageMenu();
        if (!Ext.isEmpty(Ext.getStore("AllLanguagesStore4"))){
            Ext.getStore("AllLanguagesStore4").load();
        }



    },

    extractLocFromBlocksJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("BlocsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.configBasique.title=me.insertAndReplace(extractedLoc, block.configBasique.title);
            Ext.Array.forEach(block.configBasique.champsConfig.simple, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
            Ext.Array.forEach(block.configBasique.champsConfig.avance, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFormFieldsJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("FormFieldTypesStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            if (!Ext.isEmpty(block.itemConfig.label)){
                block.itemConfig.label=me.insertAndReplace(extractedLoc, block.itemConfig.label);
            }
            if (!Ext.isEmpty(block.itemConfig.html)){
                block.itemConfig.html=me.insertAndReplace(extractedLoc, block.itemConfig.html);
            }


        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFTJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("TypesChampsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.config.fieldLabel=me.insertAndReplace(extractedLoc, block.config.fieldLabel);
            Ext.Array.forEach(block.configFields, function(field){
                field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
            });

        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    insertAndReplace: function(locObj, targetString) {
        var newId="#"+Ext.id()+"#";
        var finalId=Ext.clone(newId);
        Ext.Object.each(locObj, function(key, value, myself) {
            if (value==targetString){
                finalId=key;
            }
        });
        if (newId==finalId){
            locObj[finalId]=targetString;
        }
        return(finalId);
    },

    correctLanguageMenu: function() {
        var myMenu=Ext.getCmp("LanguageChangerMenu");
        if(!Ext.isEmpty(myMenu)){
            myMenu.removeAll();
            if (Ext.getStore("AllLanguagesStore3").getRange().length>1){
                Ext.Array.forEach(Ext.getStore("AllLanguagesStore3").getRange(),function(language){
                    var newItem=Ext.widget("menuitem",{text:language.get("label"), icon:"/assets/flags/16/"+language.get("flagCode")+".png"});
                    if (!Ext.isEmpty(language.get("ownLabel"))){
                        newItem.setText(language.get("ownLabel"));
                    }
                    newItem.on("click",function(){
                        Ext.getCmp("workingLanguageField").setValue(language.get("locale"));
                        Ext.getStore("CurrentUserDataStore").getRange()[0].set("workingLanguage",language.get("locale"));
                    });
                    myMenu.add(newItem);

                });
            } else {
                myMenu.up().hide();
            }
        }
    }

});
