/*
 * File: app/controller/LocalisationController.js
 *
 * This file was generated by Sencha Architect version 2.2.2.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Rubedo.controller.LocalisationController', {
    extend: 'Ext.app.Controller',
    alias: 'controller.LocalisationController',

    models: [
        'LocalisationModel'
    ],
    stores: [
        'LocalisationStore'
    ],

    onButtonAfterRender1: function(component, eOpts) {
        try {
            component.on("click", function(){
                Ext.widget('callout', {
                    cls: 'gray',
                    width: 400,
                    html:Rubedo.RubedoAppHelp[component.RApplication],
                    calloutArrowLocation: 'top-right',
                    target: component,
                    relativePosition: 't-b',
                    relativeOffsets: [-184,0],
                    fadeInDuration: 200,
                    fadeOutDuration: 200,
                    dismissDelay: 60000
                }).show();

            });
        } catch (err){
            console.log("failed to show application help");
        }
    },

    onComponentBeforeRender: function(component, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
                if (!Ext.isEmpty(configs.tooltip)) {
                    component.setTooltip(configs.tooltip);
                }
            }
            if ((component.isXType("button"))&&(component.scale=="large")&&(Ext.isEmpty(component.dontStretch))){
                component.minWidth=48;
            }
        }
        if ((component.isXType("field"))||(component.isXType("checkboxgroup"))||(component.isXType("radiogroup"))){
            component.labelSeparator=" ";
            if (component.name=="localizable"){
                //temporary localiser hide
                component.hide();
            }
        }
    },

    onBasefieldAdded: function(component, container, pos, eOpts) {
        if (component.localiserId){
            var configs = Rubedo.RubedoInterfaceLoc[component.localiserId];
            if (!Ext.isEmpty(configs)) {
                Ext.apply(component, configs);
            }
        }
        if (!Ext.isEmpty(component.RTip)){
            component.anchor="90%";
            container.insert(pos,Ext.widget("RHelpBtn", {tooltip:component.RTip}));
        }
    },

    onFieldsetAfterRender: function(component, eOpts) {
        var task = new Ext.util.DelayedTask(function(){
            component.setTitle(component.title);
        });
        task.delay(100);
    },

    onWorkingLanguageFieldChange: function(field, newValue, oldValue, eOpts) {
        var myBtn=Ext.getCmp("workingLanguageBtn");
        if (Ext.isEmpty(newValue)){
            myBtn.setIcon(null);
            myBtn.setIconCls("infoWarning");
            myBtn.setTooltip("No working language selected");
            myBtn.setText(null);
        } else {
            var myRec=Ext.getStore("AllLanguagesStore3").query("locale",newValue,false,false,true).items[0];
            myBtn.setIconCls(null);
            myBtn.setIcon('/assets/flags/16/'+myRec.get("iso2").toUpperCase()+'.png');
            myBtn.setTooltip("Current working language : "+myRec.get("label"));
            myBtn.setText(myRec.get("label"));
        }
    },

    onEnteteAfterRender: function(component, eOpts) {
        var task = new Ext.util.DelayedTask(function(){
            component.remove(Ext.getCmp("ESSearchField"));
            component.insert(8, Ext.widget("ESSearchField"));
            Ext.getCmp("desktopHomeBtn").setTooltip(Rubedo.RubedoAutomatedElementsLoc.showDesktopTooltip);
        });
        task.delay(600);

    },

    onWorkingLanguageBtnClick: function(button, e, eOpts) {
        Ext.widget("workingLanguageChangeWindow").show();
    },

    onCurrentLanguageChangeSubmitBtnClick: function(button, e, eOpts) {
        var form=button.up().getForm();
        if (form.isValid()){
            Ext.getCmp("workingLanguageField").setValue(form.getValues().language);
            Ext.getStore("CurrentUserDataStore").getRange()[0].set("workingLanguage",form.getValues().language);
            button.up().up().close();
        }
    },

    init: function(application) {
        var me=this;
        Ext.override(Ext.form.field.Date, {
            submitFormat:'U',
            altFormats:'U|m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d|n-j|n/j'
        });
        Ext.require("Ext.ux.callout.Callout");

        Ext.Date.defaultFormat="d/m/Y";
        //define localisation singletons 
        Ext.define("Rubedo.RubedoAppHelp",{
            singleton:true,
            "pages": "<p>The different pages of a site can easily be enriched with functional blocks.The 'Pages' application allows:</p> <ul><li>to access the tree view of sites maintained on the platform,</li> <li>to add pages based on existing pages masks</li> <li>to modify or delete pages,</li> <li> to add functionalities to pages through the library of functional blocks</li> <li>to preview the display of a page in front-office,</li> <li>to manage SEO settings,</li> <li>to manage reading and writing rights through workspaces.</li></ul>",
            "sites": "<p>Rubedo natively offers the site building feature.The 'Sites' application allows:</p> <ul><li>to create new sites through a wizard</li> <li>on the basis of existing models or from a blank template</li> <li>to modify the settings of existing sites</li></ul>",
            "masks": "<p>Pages masks represent the different rendering templates available in front office.The \"Page masks\" application allows:</p> <ul><li>to create new layout templates in rows and columns</li> <li>to duplicate existing masks, possibly from one site to another</li> <li>to manage the persistent functional blocks, such as menus</li> <li>to form a library of elements (rows, columns, or blocks) that is reusable between masks</li> <li>to manage Responsive Design settings : visibility of rows, columns and blocks on phone, tablet, or desktop</li></ul>",
            "contentTypes": "<p>Content types correspond to the structured data managed by Rubedo: articles, news,.. .etc. The 'Content Types' application allows :</p> <ul><li>to create new content types using an advanced editor</li> <li>to set up input controls, default values, mandatory state for each field</li> <li>to modify existing content types</li> <li>to manage localizable (several language), and searchable state of each field</li> <li>to manage input aid</li> <li>to declare vocabularies applicable to the classification of the contents</li> <li>to choose the workflow to apply to contents</li> <li>to declare read and write workspaces for contents</li></ul>",
            "damTypes": "<p>Digital asset types correspond to Rubedo-managed files: images, video, audio, animation or documents.'Digital Asset Types' application allows:</p> <ul><li>to create new digital asset types (image, document, video, audio, animation)</li> <li>to add metadata (author, copyright, caption, etc) using an advanced editor</li> <li>to set input controls, default values, mandatory state for each field</li> <li>to edit existing digital asset types</li> <li>to manage localizable(several language) and searchable state for each field</li> <li>to manage input aid</li> <li>to choose vocabularies eligible as classification</li> <li>to declare read and write workspaces</li></ul>",
            "queries": "<p>Queries are used to create automatic or manual lists of contents and digital assets.The \"Queries\" application allows:</p> <ul><li>to create and save simple or advanced, content or digital asset queries</li> <li>to edit or remove existing queries</li> <ul>",
            "taxonomy": "<p>Taxonomy alows for the creation of a multi-dimensional classification of contents and digital assets.The \"Taxonomy\" application allows:</p> <ul><li>to create new vocabularies and add terms using a tree</li> <li>to apply rights for workspaces and inpu aid for each vocabulary</li> <li>to define vocabulary settings: expandable, multi-choice, mandatory</li></ul>",
            "groups": "<p>Groups are used to associate users with rights in the form of workspaces and roles.The 'Groups' application allows:</p> <ul><li>to create groups of users</li> <li>to add users to these groups</li> <li>to set up the rights associated with each group: workspaces (read, write, default) and roles</li> <li>to manage groups (deletion, modification, inheritance)</li></ul>",
            "workspaces": "<p>Workspaces are used to restrict access (read, write or broadcast) on content, digital asset types or sites topics to specific user groups.The 'Workspaces' application allows:</p> <ul><li>to create workspaces</li> <li>to delete or edit workspaces</li></ul>",
            "users": "<p>Front-office and back-office users are grouped in an internal directory. The rights granted to a user are linked to groups to which he belongs.The 'Users' application allows:</p> <ul><li>to add users</li> <li>to complete profiles (email, service, job title, photo,...)</li> <li>to manage  access and rights (identifier, password, groups, account validityt)</li></ul> ",
            "contents": "<p>Rubedo manages a transverse repository of content that can be published on different sites and workspaces.The \"Contents\" application allows:</p> <ul><li>to create contents using an existing content type</li> <li>to manage its status in the workflow of publication attributed to the content type</li> <li>to manage delayed publication</li> <li>to classify content using vocabularies allowed for this contnet type</li> <li>to associate contents to contribution and diffusion workspaces</li> <li>to modify contents</li> <li>to duplicate contents</li> <li>to add contents to favorites</li></ul> ",
            "dam": "<p>The DAM allows you to manage digital assets (images, video, audio, animation or documents) based on predefined digital asset types.The \"DAM\" application allows:</p> <ul><li>to create digital assets using existing digital asset types</li> <li>to upload digital assets and apply metadata settings</li> <li>to classify digital assets using vocabularies allowed for this digital asset type</li> <li>to set up contributionand diffusion workspaces </li> <li>to edit digital assets</li> <li>to add digital assets to favorites</li></ul>",
            "forms": "<p>This application is used to conduct online surveys. Stages and questions can be easly created and manged through drag and drop. The \"Surveys\" application allows:</p> <ul><li>to add, edit, delete, and duplicate a survey</li> <li>to add a survey to favorites</li> <li>to manage the settings and unique answer conditions of a survey and put it online</li> <li>to create a survey using the tool palette of formatting (Wysiwyg, image, section, page, title) and settings (type of questions and their specific settings)</li> <li>to manage questions and answers (label settings(, input aid, mandatory state, conditionals, and options)</li> <li>to exploit the results of each survey by exporting to CSV format</li></ul>"

        });
        Ext.define("Rubedo.RubedoInterfaceLoc",{
            singleton:true
        });
        Ext.define("Rubedo.RubedoAutomatedElementsLoc",{
            singleton:true,
            "notifTitle": "Notification",
            "notifCreate": "<p>Succesful creation.</p>",
            "notifUpdate": "<p>Successful update.</p>",
            "notifDestroy": "<p>Successful deletion.</p>",
            "errorTitle": "Error",
            "serverConnectionError": "Server connection interrupted",
            "internalServerError": "Internal server error",
            "unkownError": "Unknown error",
            "activateText": "Activate",
            "pageHoldsDefaultError": "This page cannot be deleted because it u one of its decendantes is used as a detail of the site page",
            "pageHoldsDefaultServerError": "Error in the determination of the deletable status of the page",
            "deactivateText": "Disable",
            "windowBeforeUnloadMessage": "You will leave the Back Office and lose any unsaved changes.",
            "maskIsUsedText": "The mask cannot be deleted because it is used by pages.",
            "selectAnElementText": "Select an item",
            "columnText": "Column",
            "lignText": "Line",
            "titleText": "Title",
            "displayTitleText": "Display the title",
            "visibilityText": "Visibility",
            "telephoneText": "Phone",
            "tabletText": "Tablet",
            "computerText": "Desktop",
            "HTMLClassText": "HTML class",
            "HTMLIdText": "HTML ID",
            "styleText": "Style",
            "tagText": "Tag",
            "displayAsTabsText": "Display in tabs",
            "displayRowTagText": "Display the row tag",
            "displayRowFluidTagText": "Show row-fluid tag",
            "includeInAContainerText": "Include in a container",
            "includeInAContainerFluidText": "Include in a fluid container",
            "containerIdText": "ID of the container",
            "containerClassText": "Container class",
            "mainColumnText": "Main column",
            "mainColumnRTip": "Sets the display location for content detail in pages using this mask.",
            "showSpanAndOffsetText": "Display the span and offset",
            "offsetText": "Offset",
            "spanText": "Span",
            "columnIdRecoveryError": "Error in the recovery of a column identifier",
            "displayInADivText": "Display in a div",
            "divIdText": "ID of the div",
            "divClassText": "The div class",
            "blockText": "Block",
            "URLPrefixText": "URL Prefix",
            "invalidMetaError": "Some metadata fields are invalid.",
            "invalidTaxoError": "Some taxonomy fields are invalid.",
            "invalidFieldsError": "Some fields are invalid.",
            "insufficientContentRightsError": "You have insufficient rights to view or modify this content",
            "newContentText": "New content",
            "maxOneLocFieldError": "A content type cannot have multiple fields of type \"Location\".",
            "contentTypeIsUsedError": "This content type is used by content and therefore cannot be deleted.",
            "warningTitle": "Warning",
            "contentTypeIncompatModifError": "The content type is used by content and these amendments are not compatible.",
            "contentTypeModifWarning": "This content type is used by content. Changing it could have repercussions. </br> Would you like to continue?",
            "fieldReplicaText": "Replica of the field",
            "successTitle": "Success",
            "contentsDeleteError": "Error in deleting content",
            "contentTypeHasBeenEmptiedText": "The content type has been emptied",
            "fieldNameAlreadyUsedError": "Name already used by another field",
            "passwordsDoNotMatchError": "Passwords don't match",
            "passwordChangedText": "Password changed",
            "rightsRecoveryError": "Error in the recovery of the rights",
            "tokenRecoveryError": "Error in retrieving the security token",
            "siteModifWarning": "The modification of this site will involve the closing of the page management window. This will result in the loss of any changes not saved in that window. </br> Do you want to continue?",
            "pageURLRecoveryError": "Error in retrieving the url of the page",
            "pagePreviewText": "This is an overview of this page as available online on",
            "associatedMaskText": "Associated mask",
            "pagePropertiesInvalidError": "The properties of the page are invalid.",
            "stageText": "Step",
            "onText": "out of",
            "ascText": "Ascending",
            "descText": "Descending",
            "andText": "And",
            "thenText": "Then",
            "mediaTypeIsUsedError": "This type of media is used by media and therefore cannot be deleted.",
            "invalidRightsPropertiesError": "Invalid rights configuration",
            "newDamText": "New media",
            "DAMEditText": "Edition of the media",
            "DAMDisplayText": "Display of the media",
            "searchText": "Search",
            "identifierRecoveryError": "Error in the recovery of an identifier",
            "invalidFormPropertiesError": "Invalid form properties",
            "fileAnalysisError": "Error in parsing the file",
            "identifiedFieldsText": "identified fields and",
            "importableContentsText": "importable contents",
            "importedContentsText": "contents imported",
            "importError": "Error during import",
            "eligibleContentTypesText": "Eligible content types",
            "eachContentMustVerifyRulesText": "Each content must verify the following rules",
            "eachContentMustVerifyAtLeastOneRuleText": "Each content must verify at least one of the following rules",
            "taxonomyText": "Taxonomy",
            "rulesAndSortsOnFieldsText": "Rules and sorting on content fields",
            "ascSortText": "Sort ascending",
            "descSortText": "sort descending",
            "relationBetweenRulesText": "Relationship between the rules",
            "creationText": "Creation",
            "lastUpdateText": "Last modified",
            "noVocabForTheseCtText": "No vocabulary available for this set of content types",
            "ruleText": "Rule",
            "tRuleAllText": "Contains all the terms",
            "tRuleAllRecText": "Contains all the terms or at least a descendant per term",
            "tRuleSomeText": "Contains at least one of the terms",
            "tRuleSomeREcText": "Contains at least one of the terms or at least one of the descendants of one of the terms",
            "tRuleNotText": "Does not contain any of the following terms",
            "tRuleNotRecText": "Does not contain the following terms or their descendants",
            "CTMustHaveTitleError": "The content type must have a 'Title' field",
            "CTMustHaveOnlyOneTitleError": "The content type must have only a single field of type \"title\"",
            "CTMustHaveOnlyOneSummaryError": "The content type must have only a single field of type \"Summary\"",
            "CRMustHaveOnlyOneLocFieldError": "The content type must have only a single field of type 'Location'",
            "notMentionedText": "not filled",
            "showOnlyIfText": "Displayed if and only if",
            "orText": "Or",
            "rootText": "Root",
            "esGeoQueryText": "Geolocated Elastic Search Query Wizard",
            "esQueryText": "Elastic Search Query Wizard",
            "esDAMQueryText": "DAM Elastic Search Query Wizard",
            "keywordsText": "Keywords",
            "defaultKeywordsText": "Default keywords",
            "defaultSinglePageText": "Default detail page",
            "homePageText": "Homepage",
            "rolesText": "Roles",
            "authorText": "Author",
            "versionText": "Version",
            "contentsText": "Contents",
            "displayText": "Display",
            "publishedText": "published",
            "pendingText": "pending validation",
            "draftText": "draft",
            "refusedText": "refused",
            "yesText": "Yes",
            "noText": "No",
            "mediasText": "Media",
            "simpleQueryText": "Simple query",
            "manualQueryText": "Manual query",
            "restoreText": "Restore",
            "originalFileMText": "Original file *",
            "noneText": "None",
            "basicText": "Basic",
            "formUniqueAnswerMessage": "You have already completed this survey. Thank you.",
            "formEndMessage": "Thank you for completing this survey.",
            "oldVersionText": "(A more recent version of Rubedo is available)",
            "summaryText": "Summary",
            "showDesktopTooltip": "Show desktop",
            "userText":"user",
            "usersText":"users",
            "emptyText":"empty",
            "groupsText":"Groups",
            "removeText":"Remove",
            "duplicateFieldText":"Duplicate of the field",
            "duplicateText":"Duplicate",
            "multivaluedText":"Multivalued",
            "searchableText":"Searchable",
            "localizableText":"Localizable",
            "optionalText":"Optional",
            "fileTypeText":"File type",
            "tooltipText":"Tooltip",
            "nameText":"Name",
            "labelText":"Label",
            "fileFieldText":"File",
            "fileFieldDescription":"<h2>File field<\/h2> <\/br> <p>This field allows for the upload of files.<\/p>",
            "databaseIsUpToDateText":"Database is up to date",
            "databaseNeedsUpdateText":"Database update required",
            "databaseUpdateWarning":"This action will update the Rubedo database. It is recommended that you back-up your data before starting. Would you like to continue ?",
            "databaseUpdatedToText":"The database has been updated to version",
            "folderViewText":"Folder view",
            "switchToFolderViewText": "Switch to folder view",
            "searchViewText":"Search view",
            "switchToSearchViewText":"Switch to search view",
            "notFiledText": "Not filed",
            "mediaTypeText":"Media type",
            "filesUploadedText":"files uploaded",
            "allText":"All",
            "contentTypeText":"Content type",
            "encodingText":"Encoding",
            "siteLanguageChoiceError":"The default site language must be one of the site languages",
            "delconBaseText":"Are you sure you want to delete",
            "thisMaskText":"this page mask",
            "thisPageText": "this page",
            "thisContentTypeText":"this content type",
            "thisMediaTypeText":"this media type",
            "thisSurveyText":"this survey",
            "thisFolderText":"this folder",
            "thisMediaText":"this digital asset",
            "thisVocabularyText":"this vocabulary",
            "atLeastOneLocError":"At least one language must be active"
        });


        this.control({
            "#RHelpBtn": {
                afterrender: this.onButtonAfterRender1
            },
            "component": {
                beforerender: this.onComponentBeforeRender
            },
            "field, checkboxgroup, radiogroup": {
                added: this.onBasefieldAdded
            },
            "fieldset": {
                afterrender: this.onFieldsetAfterRender
            },
            "#workingLanguageField": {
                change: this.onWorkingLanguageFieldChange
            },
            "#entete": {
                afterrender: this.onEnteteAfterRender
            },
            "#workingLanguageBtn": {
                click: this.onWorkingLanguageBtnClick
            },
            "#currentLanguageChangeSubmitBtn": {
                click: this.onCurrentLanguageChangeSubmitBtnClick
            }
        });
    },

    produceInterfaceLocalisationJSON: function() {
        var result= { };
        var count=0;
        Ext.Object.each(Rubedo.view, function(a){
            var test=Ext.create("Rubedo.view."+a,{id:undefined});
            if (!Ext.isEmpty(test.localiserId)){
                count=count+1;
                if ((test.isXType("field"))||(test.isXType("radiogroup"))||(test.isXType("checkboxgroup"))){
                    result[test.localiserId]={
                        fieldLabel:test.fieldLabel,
                        boxLabel:test.boxLabel,
                        buttonText:test.buttonText,
                        RTip:test.RTip
                    };
                } else if (test.isXType("button")){
                    result[test.localiserId]={
                        text:test.text,
                        tooltip:test.tooltip
                    };
                } else if (test.isXType("menuitem")){
                    result[test.localiserId]={
                        text:test.text,
                        tooltip:test.tooltip
                    };
                }else if (test.isXType("fieldset")){
                    result[test.localiserId]={
                        title:test.title
                    };
                } else if (test.isXType("panel")){
                    result[test.localiserId]={
                        title:test.title,
                        tooltip:test.tooltip
                    };
                } else if (test.isXType("window")){
                    result[test.localiserId]={
                        title:test.title
                    };
                }else if (test.isXType("gridcolumn")){
                    result[test.localiserId]={
                        text:test.text
                    };
                } else {
                    console.log("unhandled localised component for id : "+test.localiserId); 
                    count=count-1;
                }
                if (!Ext.isEmpty(result[test.localiserId])){
                    Ext.Object.each(result[test.localiserId], function(key, value, myself) {
                        if (Ext.isEmpty(value)){
                            delete result[test.localiserId][key];
                        }
                    });
                }
            }
            try{
                Ext.Array.forEach(test.query("component"), function(component){
                    if (!Ext.isEmpty(component.localiserId)){
                        count=count+1;
                        if ((component.isXType("field"))||(component.isXType("radiogroup"))||(component.isXType("checkboxgroup"))){
                            result[component.localiserId]={
                                fieldLabel:component.fieldLabel,
                                boxLabel:component.boxLabel,
                                buttonText:component.buttonText,
                                RTip:component.RTip
                            };
                        } else if (component.isXType("button")){
                            result[component.localiserId]={
                                text:component.text,
                                tooltip:component.tooltip
                            };
                        } else if (component.isXType("menuitem")){
                            result[component.localiserId]={
                                text:component.text
                            };
                        }else if (component.isXType("fieldset")){
                            result[component.localiserId]={
                                title:component.title
                            };
                        } else if (component.isXType("panel")){
                            result[component.localiserId]={
                                title:component.title,
                                tooltip:component.tooltip
                            };
                        } else if (component.isXType("window")){
                            result[component.localiserId]={
                                title:component.title
                            };
                        }else if (component.isXType("gridcolumn")){
                            result[component.localiserId]={
                                text:component.text
                            };
                        } else {
                            console.log("unhandled localised component for id : "+component.localiserId); 
                            count=count-1;
                        }
                        if (!Ext.isEmpty(result[component.localiserId])){
                            Ext.Object.each(result[component.localiserId], function(key, value, myself) {
                                if (Ext.isEmpty(value)){
                                    delete result[component.localiserId][key];
                                }
                            });
                        }
                    }
                });

            }catch(err){
                console.log(err);
            }
            test.destroy();
        });
        console.log(count+" localised interface components");
        return(Ext.JSON.encode(result));
    },

    updateLocalisationSingletons: function() {
        var userLanguage=Ext.getStore("CurrentUserDataStore").getRange()[0].get("language");
        if (Ext.isEmpty(userLanguage)){
            userLanguage="en";
        }
        if (userLanguage=="en"){
            Ext.Date.defaultFormat="m/d/Y";
        }
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/appHelp.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAppHelp, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAppHelp singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/componentLabels.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoInterfaceLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoInterfaceLoc singleton could not be localized for the current language");
            }
        });
        Ext.Ajax.request({
            url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/automatedElements.json',
            params: {

            },
            success: function(response){
                var singletonUpdates = Ext.JSON.decode(response.responseText);
                Ext.apply(Rubedo.RubedoAutomatedElementsLoc, singletonUpdates);
            },
            failure:function(){
                console.log("RubedoAutomatedElementsLoc singleton could not be localized for the current language");
            }
        });
        if (!Ext.isEmpty(Ext.getStore("TypesChampsDataStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/fieldTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/fieldTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("TypesChampsDataStore").removeAll();
                            Ext.getStore("TypesChampsDataStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("FieldTypes store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("FieldTypes store could not retrieve generic structure");
                }
            });
        }
        if (!Ext.isEmpty(Ext.getStore("BlocsDataStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/blockTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/blockTypeLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("BlocsDataStore").removeAll();
                            Ext.getStore("BlocsDataStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("Blocks store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("Blocks store could not retrieve generic structure");
                }
            });
        }
        if (!Ext.isEmpty(Ext.getStore("FormFieldTypesStore"))){
            Ext.Ajax.request({
                url: 'resources/localisationfiles/generic/formFieldTypes.json',
                params: {

                },
                success: function(response){
                    var genericStructureString = response.responseText;
                    Ext.Ajax.request({
                        url: '/components/webtales/rubedo-localization/'+userLanguage+'/BackOffice/formFieldLabels.json',
                        params: {

                        },
                        success: function(response){
                            var localisedLabels =Ext.JSON.decode(response.responseText);
                            Ext.Object.each(localisedLabels, function(key, value, myself) {
                                replacer=new RegExp(key, 'g');
                                genericStructureString=genericStructureString.replace(replacer, value);
                            });
                            var decodedFT=Ext.JSON.decode(genericStructureString);
                            Ext.getStore("FormFieldTypesStore").removeAll();
                            Ext.getStore("FormFieldTypesStore").loadData(decodedFT);


                        },
                        failure:function(){
                            console.log("Form Fields store could not be localised for this language");
                        }
                    });
                },
                failure:function(){
                    console.log("Form Fields store could not retrieve generic structure");
                }
            });
        }




    },

    extractLocFromBlocksJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("BlocsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.configBasique.title=me.insertAndReplace(extractedLoc, block.configBasique.title);
            Ext.Array.forEach(block.configBasique.champsConfig.simple, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
            Ext.Array.forEach(block.configBasique.champsConfig.avance, function(category){
                category.categorie=me.insertAndReplace(extractedLoc, category.categorie);
                Ext.Array.forEach(category.champs, function(field){
                    field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
                    if (!Ext.isEmpty(field.autoStoreData)){
                        Ext.Array.forEach(field.autoStoreData, function(option){
                            option.label=me.insertAndReplace(extractedLoc, option.label);
                        });
                    }
                });
            });
        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFormFieldsJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("FormFieldTypesStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            if (!Ext.isEmpty(block.itemConfig.label)){
                block.itemConfig.label=me.insertAndReplace(extractedLoc, block.itemConfig.label);
            }
            if (!Ext.isEmpty(block.itemConfig.html)){
                block.itemConfig.html=me.insertAndReplace(extractedLoc, block.itemConfig.html);
            }


        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    extractLocFromFTJson: function() {
        var me = this;
        var data = Ext.clone(Ext.Array.pluck(Ext.getStore("TypesChampsDataStore").getRange(), "data"));
        var extractedLoc = { };
        Ext.Array.forEach(data, function(block){
            block.category=me.insertAndReplace(extractedLoc, block.category);
            block.type=me.insertAndReplace(extractedLoc, block.type);
            block.description=me.insertAndReplace(extractedLoc, block.description);
            block.config.fieldLabel=me.insertAndReplace(extractedLoc, block.config.fieldLabel);
            Ext.Array.forEach(block.configFields, function(field){
                field.config.fieldLabel=me.insertAndReplace(extractedLoc, field.config.fieldLabel);
            });

        });
        console.log(Ext.JSON.encode(extractedLoc));
        console.log("\n \n");
        console.log(Ext.JSON.encode(data));
    },

    insertAndReplace: function(locObj, targetString) {
        var newId="#"+Ext.id()+"#";
        var finalId=Ext.clone(newId);
        Ext.Object.each(locObj, function(key, value, myself) {
            if (value==targetString){
                finalId=key;
            }
        });
        if (newId==finalId){
            locObj[finalId]=targetString;
        }
        return(finalId);
    }

});
